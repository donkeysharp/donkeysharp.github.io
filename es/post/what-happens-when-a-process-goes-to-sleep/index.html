<!DOCTYPE html>
<html lang="es" itemscope itemtype="http://schema.org/WebPage">
  <head>
    

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

 


      <title>Qu√© sucede cuando un proceso de Linux se va a dormir? - Mi Blog</title>

  <meta name="description" content="Es posible que cuando estas escribiendo un programa, en alg√∫n momento necesites pausar la ejecuci√≥n de un proceso llamando a la funci√≥n sleep(NUMBER_OF_SECONDS) dependiendo del problema que est√©s resolviendo. En este post, compartir√© lo que aprend√≠ hasta ahora mientras investigaba los mecanismos internos del kernel que hacen que la funci√≥n sleep funcione de la forma en que lo hace.
Agradezco su feedback. No soy un experto en este tema ya que las partes internas del Kernel de Linux son nuevas para m√≠, fue solo mi curiosidad lo que me llev√≥ a revisar el c√≥digo fuente del Kernel y quer√≠a compartir lo que aprend√≠.">
  <meta name="author" content="Sergio Guillen"/><script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "WebSite",
    "name": "Sergio Guillen",
    
    "url": "https:\/\/blog.donkeysharp.xyz"
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Organization",
  "name": "",
  "url": "https:\/\/blog.donkeysharp.xyz"
  
  
  
  
}
</script>
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
        "@type": "ListItem",
        "position": 1,
        "item": {
          "@id": "https:\/\/blog.donkeysharp.xyz",
          "name": "home"
        }
    },{
        "@type": "ListItem",
        "position": 3,
        "item": {
          "@id": "https:\/\/blog.donkeysharp.xyz\/es\/post\/what-happens-when-a-process-goes-to-sleep\/",
          "name": "Qu√© sucede cuando un proceso de linux se va a dormir?"
        }
    }]
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "author": {
    "name" : "Sergio Guillen"
  },
  "headline": "Qu√© sucede cuando un proceso de Linux se va a dormir?",
  "description" : "Es posible que cuando estas escribiendo un programa, en alg√∫n momento necesites pausar la ejecuci√≥n de un proceso llamando a la funci√≥n sleep(NUMBER_OF_SECONDS) dependiendo del problema que est√©s resolviendo. En este post, compartir√© lo que aprend√≠ hasta ahora mientras investigaba los mecanismos internos del kernel que hacen que la funci√≥n sleep funcione de la forma en que lo hace.\nAgradezco su feedback. No soy un experto en este tema ya que las partes internas del Kernel de Linux son nuevas para m√≠, fue solo mi curiosidad lo que me llev√≥ a revisar el c√≥digo fuente del Kernel y quer√≠a compartir lo que aprend√≠.",
  "inLanguage" : "es",
  "wordCount":  3081 ,
  "datePublished" : "2022-03-10T00:00:00",
  "dateModified" : "2022-03-10T00:00:00",
  "image" : "https:\/\/blog.donkeysharp.xyz\/img\/donkeysharp.png",
  "keywords" : [ "" ],
  "mainEntityOfPage" : "https:\/\/blog.donkeysharp.xyz\/es\/post\/what-happens-when-a-process-goes-to-sleep\/",
  "publisher" : {
    "@type": "Organization",
    "name" : "https:\/\/blog.donkeysharp.xyz",
    "logo" : {
        "@type" : "ImageObject",
        "url" : "https:\/\/blog.donkeysharp.xyz\/img\/donkeysharp.png",
        "height" :  60 ,
        "width" :  60
    }
  }
}
</script>

<meta property="og:title" content="Qu√© sucede cuando un proceso de Linux se va a dormir?" />
<meta property="og:description" content="Es posible que cuando estas escribiendo un programa, en alg√∫n momento necesites pausar la ejecuci√≥n de un proceso llamando a la funci√≥n sleep(NUMBER_OF_SECONDS) dependiendo del problema que est√©s resolviendo. En este post, compartir√© lo que aprend√≠ hasta ahora mientras investigaba los mecanismos internos del kernel que hacen que la funci√≥n sleep funcione de la forma en que lo hace.
Agradezco su feedback. No soy un experto en este tema ya que las partes internas del Kernel de Linux son nuevas para m√≠, fue solo mi curiosidad lo que me llev√≥ a revisar el c√≥digo fuente del Kernel y quer√≠a compartir lo que aprend√≠.">
<meta property="og:image" content="https://blog.donkeysharp.xyz/img/donkeysharp.png" />
<meta property="og:url" content="https://blog.donkeysharp.xyz/es/post/what-happens-when-a-process-goes-to-sleep/" />
<meta property="og:type" content="website" />
<meta property="og:site_name" content="Sergio Guillen" />

  <meta name="twitter:title" content="Qu√© sucede cuando un proceso de Linux se va a dormir?" />
  <meta name="twitter:description" content="Es posible que cuando estas escribiendo un programa, en alg√∫n momento necesites pausar la ejecuci√≥n de un proceso llamando a la funci√≥n sleep(NUMBER_OF_SECONDS) dependiendo del problema que est√©s ‚Ä¶">
  <meta name="twitter:image" content="https://blog.donkeysharp.xyz/img/donkeysharp.png" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="@donkeysharp" />
  <meta name="twitter:creator" content="@donkeysharp" />
  <meta name="generator" content="Hugo 0.118.2">
  <link rel="alternate" href="https://blog.donkeysharp.xyz/es/index.xml" type="application/rss+xml" title="Sergio Guillen"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css" integrity="sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/css/bootstrap.min.css" integrity="sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu" crossorigin="anonymous"><link rel="stylesheet" href="https://blog.donkeysharp.xyz/css/main.css" /><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" />
  <link rel="stylesheet" href="https://blog.donkeysharp.xyz/css/highlight.min.css" /><link rel="stylesheet" href="https://blog.donkeysharp.xyz/css/codeblock.css" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css" integrity="sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css" integrity="sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R" crossorigin="anonymous"><link rel="stylesheet" href="https://blog.donkeysharp.xyz/css/custom.css">

<script async src="https://www.googletagmanager.com/gtag/js?id=G-NE86EKXE5N"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-NE86EKXE5N', { 'anonymize_ip': false });
}
</script>

  </head>
  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">Conmuta navegaci√≥n</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://blog.donkeysharp.xyz/es/">DONKEYSHARP</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li>
              <a title="Blog" href="https://blog.donkeysharp.xyz/es">Blog</a>
            </li>
          
        
          
            <li>
              <a title="Sobre m√≠" href="https://blog.donkeysharp.xyz/es/about/">Sobre m√≠</a>
            </li>
          
        

        
          
            <li>
              
                
                  <a href="https://blog.donkeysharp.xyz/en" lang="en" title="English">
                    <img src="https://blog.donkeysharp.xyz/img/flags/en.png" />
                  </a>
                
              
                
              
            </li>
          
        

        
      </ul>
    </div>

    
      <div class="avatar-container">
        <div class="avatar-img-border">
          <a title="Sergio Guillen" href="https://blog.donkeysharp.xyz/es/">
            <img class="avatar-img" src="https://blog.donkeysharp.xyz/img/donkeysharp.png" alt="Sergio Guillen" />
          </a>
        </div>
      </div>
    

  </div>
</nav>




    


<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>


  
  
  






  

  <header class="header-section ">
    
    
    <div class="intro-header no-img">
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <div class="post-heading">
              
                <h1>Qu√© sucede cuando un proceso de Linux se va a dormir?</h1>
              
              
              
              
                <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;Publicado el Mar 10, 2022
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;15&nbsp;minutos
  
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;Sergio Guillen
    
  
  &nbsp;&bull;&nbsp;Tambi√©n en: <a href="https://blog.donkeysharp.xyz/post/what-happens-when-a-process-goes-to-sleep/" lang="en">English</a>
</span>


              
            </div>
          </div>
        </div>
      </div>
    </div>
  
  </header>


    
<div class="container" role="main">
  <div class="row">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
      <article role="main" class="blog-post">
        <p>Es posible que cuando estas escribiendo un programa, en alg√∫n momento necesites pausar la ejecuci√≥n de un proceso llamando a la funci√≥n <code>sleep(NUMBER_OF_SECONDS)</code> dependiendo del problema que est√©s resolviendo. En este post, compartir√© lo que aprend√≠ hasta ahora mientras investigaba los mecanismos internos del kernel que hacen que la funci√≥n <code>sleep</code> funcione de la forma en que lo hace.</p>
<blockquote>
<p><strong>Agradezco su feedback.</strong> No soy un experto en este tema ya que las partes internas del Kernel de Linux son nuevas para m√≠, fue solo mi curiosidad lo que me llev√≥ a revisar el c√≥digo fuente del Kernel y quer√≠a compartir lo que aprend√≠. Si encuentran algo incorrecto en este post, pueden abrir un issue en el <a href="https://github.com/donkeysharp/donkeysharp.github.io">repositorio de Github</a> de este blog. Gracias!.</p>
</blockquote>
<h2 id="process-state">Process State</h2>
<p>Uno de los primeros conceptos que necesitamos revisar es el estado de un proceso. Un proceso en Linux tiene un estado asociado que representa su estado de ejecuci√≥n en el sistema operativo. Un proceso puede estar en uno de los siguientes estados:</p>
<ul>
<li>Running</li>
<li>Sleeping (interruptible and uninterruptible)</li>
<li>Stopped</li>
<li>Zombie</li>
</ul>
<p>Cuando un proceso est√° ejecutando instrucciones en la CPU, se encuentra en estado &ldquo;Running&rdquo; y cuando el proceso est√° esperando que suceda algo, es decir, esperando I/O de red o disco, o se llama a la funcion <code>sleep</code>, cambiar√° a un estado <code>Sleeping</code>.</p>
<p>Podemos comprobarlo con un sencillo programa de ejemplo en C:</p>
<pre tabindex="0"><code>// states.c
// gcc states.c -o states
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

#define SOME_MAGIC_NUMBER 365000000l

void start_processing() {
  long i;
  printf(&#34;Starting Loop\n&#34;);
  for (i = 0; i &lt; (long)(10 * SOME_MAGIC_NUMBER); i++);
  printf(&#34;Loop Finished\n&#34;);
}

int main() {
  pid_t pid = getpid();
  printf(&#34;PID: %d\n&#34;, pid);
  start_processing();
  printf(&#34;Sleep process\n&#34;);
  sleep(5);
  printf(&#34;Sleep finished\n&#34;);
  start_processing();
  return 0;
}
</code></pre><p>El c√≥digo anterior ejecutar√° un loop durante algunos segundos, luego se suspender√° durante 5 segundos y finalmente ejecutar√° otro loop durante otro n√∫mero de segundos. Por lo tanto, esperamos que el estado del proceso sea <code>Running -&gt; Sleeping -&gt; Running</code>.</p>
<p>Mientras se ejecuta el programa, podemos comprobar el estado del proceso con la herramienta <a href="https://htop.dev/">Htop</a>, que normalmente mostrar√° una letra en la octava columna que representa el estado del proceso, e.g. <code>R</code> (Running), <code>S</code> (Sleeping), <code>T</code> (Stopped), etc.</p>
<p><img src="https://blog.donkeysharp.xyz/img/sleep-post/process-state.gif" alt=""></p>
<p>Como era de esperar, los estados que ten√≠a el proceso durante la ejecuci√≥n fueron: <code>Running (R) -&gt; Sleeping (S) -&gt; Running (R)</code>.</p>
<h3 id="tldr-super-resumido">TL;DR (super resumido)</h3>
<p>Cuando un programa llama a la funci√≥n <code>sleep(NUMBER_OF_SECONDS)</code> (en C), este usar√° la llamada al sistema (syscall) <code>nanosleep</code>. Otros lenguajes de programaci√≥n usan diferentes syscalls que tambi√©n pueden enviar un proceso a dormir durante algunos segundos, e.g. <code>select</code>.</p>
<p>La implementaci√≥n del kernel de Linux de la syscall <code>nanosleep</code> har√° lo siguiente:</p>
<ul>
<li>Inicializar un High Resolution sleep timer.</li>
<li>Cambiar el estado del proceso a <code>TASK_INTERRUPTIBLE (Sleeping)</code>.</li>
<li>Inicia el High Resolution sleep timer.</li>
<li>Indicar al scheduler de procesos para poner a otro proceso en ejecuci√≥n y pausar la ejecuci√≥n del proceso actual.</li>
</ul>
<p>El kernel de Linux procesa los High Resolution Timers de la siguiente manera:</p>
<ul>
<li>El hardware de la computadora tiene un CPU timer que causa interrupciones peri√≥dicamente, haciendo que el kernel las maneje llamando a la funci√≥n <code>hrtimer_interrupt</code>.</li>
<li>La funci√≥n <code>hrtimer_interrupt</code> procesar√° los High Resolution Timers (a nivel de software) existentes y ver√° si un timer expir√≥. Una vez que un High Resolution Timer expire, el kernel llamar√° a la funci√≥n <code>hrtimer_wakeup</code> que activar√° el proceso asociado con el timer, y eso cambiar√° el estado de <code>TASK_INTERRUPTIBLE (Sleeping)</code> a <code>TASK_RUNNING (Running)</code>.</li>
<li>Finalmente, algunos ciclos de CPU m√°s tarde, el scheduler de procesos continuar√° la ejecuci√≥n del proceso exactamente donde se detuvo.</li>
</ul>
<p>Sigue leyendo si est√° interesado en m√°s detalles.</p>
<h2 id="yendo-m√°s-a-fondo">Yendo M√°s A Fondo</h2>
<p>Como ingenieros de software, es probable que la mayor parte del tiempo estemos escribiendo aplicaciones que se ejecutan en <a href="https://en.wikipedia.org/wiki/User_space">user space o user mode</a>, como servidores (de cualquier tipo) o aplicaciones del lado del servidor, web , aplicaciones m√≥viles o de escritorio, scripts de automatizaci√≥n, etc.</p>
<p>No importa el lenguaje de programaci√≥n, el framework o la tecnolog√≠a, internamente un programa que se ejecuta en user mode siempre interactuar√° de una forma u otra con el sistema operativo (en este post Linux) a trav√©s de <a href="https://en.wikipedia.org/wiki/System_call">System Calls o syscalls</a>. Por ejemplo, cuando leemos un archivo, nuestro c√≥digo (sin importar el lenguaje de programaci√≥n) se comunicar√° indirectamente con el Kernel de Linux a trav√©s de la syscall <code>read</code> (no es la √∫nica), luego el kernel le pedir√° al disco duro f√≠sico el contenido del archivo que queremos basado en el sistema de archivos, y finalmente devolver√° el contenido solicitado a nuestro programa.</p>
<p>Hay una herramienta llamada <a href="https://man7.org/linux/man-pages/man1/strace.1.html">Strace</a> que monitorea todas las syscall que ejecuta un proceso.</p>
<p>Si ejecutamos el ejemplo anterior en C usando <code>strace</code>, podemos ver la siguiente salida:</p>
<pre tabindex="0"><code>$ strace ./states

... syscalls for process loading (they won&#39;t be useful right now) ...

write(1, &#34;PID: 26846\n&#34;, 11PID: 26846
)            = 11
write(1, &#34;Starting Loop\n&#34;, 14Starting Loop
)         = 14
write(1, &#34;Loop Finished\n&#34;, 14Loop Finished
)         = 14
write(1, &#34;Sleep process\n&#34;, 14Sleep process
)         = 14
nanosleep({tv_sec=5, tv_nsec=0}, 0x7ffefc933be0) = 0
write(1, &#34;Sleep finished\n&#34;, 15Sleep finished
)        = 15
write(1, &#34;Starting Loop\n&#34;, 14Starting Loop
)         = 14
write(1, &#34;Loop Finished\n&#34;, 14Loop Finished
)         = 14
exit_group(0)                           = ?
+++ exited with 0 +++
</code></pre><p>La salida verdadera es m√°s larga que la que se muestra arriba, pero la mayor√≠a de las primeras syscalls siempre se ejecutan cuando se inicia un proceso y carga la biblioteca est√°ndar de C entre otras cosas, pero las que nos interesa revisar son las √∫ltimas.</p>
<p>La syscall <code>write</code> le dice al Kernel que el programa quiere mostrar una cadena de texto en la <a href="https://en.wikipedia.org/wiki/Standard_streams#Standard_output_(stdout)">salida est√°ndar</a> (en este caso la terminal). Con esa informaci√≥n, podemos tener una idea de que la funci√≥n <code>printf</code> se comunica con el sistema operativo llamando a la syscall <code>write</code>.</p>
<p>Luego se llama a la syscall <code>nanosleep</code>, que indicar√° al kernel de Linux que mueva el proceso de un estado Running a un estado Sleeping.</p>
<p>Antes de revisar la implementaci√≥n en Linux de la syscall <code>nanosleep</code>, primero tenemos que revisar un par de conceptos para tener una mejor comprensi√≥n de lo que viene.</p>
<h3 id="high-resolution-timers">High Resolution Timers</h3>
<p>Dentro del kernel de Linux, diferentes componentes deben esperar un tiempo antes de ejecutar algo, aqu√≠ es donde entra el concepto de Timers. Un timer es una estructura (struct) en la que definimos su tiempo de expiraci√≥n (el tiempo de espera) y qu√© funci√≥n se llamar√° una vez que el timer expira.</p>
<p>El kernel de Linux tiene dos tipos de timers: Low Resolution Timers y High Resolution Timers. Revisaremos los Hight Resolution Timers.</p>
<p>El framework detr√°s de los High Resolution Timers dentro del kernel de Linux es un conjunto de structs y funciones que procesan los timers de manera √≥ptima. Su implementaci√≥n se basa en una cola de timers que se ordenan por el timer que expirar√° m√°s pronto. Para que esta cola sea eficiente, utiliza la estructura de datos <a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">Red Black Tree</a> para que la inserci√≥n y la eliminaci√≥n se puedan realizar en tiempo logar√≠tmico.</p>
<p>Este framework es muy interesante como tal, en este art√≠culo solo revisaremos c√≥mo se usa y algunas partes espec√≠ficas de su implementaci√≥n. Para obtener m√°s informaci√≥n sobre los detalles de implementaci√≥n, lea <a href="#references">[0]</a>, <a href="#references">[1]</a> y <a href="#references">[2]</a>.</p>
<blockquote>
<p>La gesti√≥n del tiempo o time management dentro del kernel de Linux es un tema muy interesante y la charla dada por <a href="https://www.linkedin.com/in/stephen-w-boyd/">Stephen Boyd</a> titulada <strong>&ldquo;Timekeeping In The Linux Kernel&rdquo;</strong> <a href="#references">[4]</a> me dio una mejor comprensi√≥n de c√≥mo el Kernel de Linux maneja las tareas relacionadas al tiempo, as√≠ como su complejidad. Esta charla me ayud√≥ mucho. ¬°Gracias!</p>
</blockquote>
<h3 id="hardware-timer">Hardware Timer</h3>
<p>La CPU (f√≠sicamente) tiene un reloj e internamente tiene un timer programable. En palabras simples, el objetivo principal de este timer es causar <a href="https://en.wikipedia.org/wiki/Interrupt#Hardware_interrupts">interrupciones</a> peri√≥dicamente (muchas veces dentro de un segundo) para que el kernel pueda manejarlas. La frecuencia de estas interrupciones depender√° de la arquitectura que se especifique en el Kernel de Linux durante su compilaci√≥n. El kernel de Linux abstrae esto como <a href="https://www.kernel.org/doc/html/latest/timers/timekeeping.html#clock-events">Clock Event Devices</a> y hay un Clock Event Device por CPU. Se utiliza un Clock Event Device para programar la siguiente interrupci√≥n que se generar√° <a href="#references">[3]</a>.</p>
<p>Cuando ocurre una interrupci√≥n del timer, el kernel de Linux lo manejar√° llamando a una funci√≥n. <a href="#references">[4]</a> menciona que para los High Resolution Timers, la funci√≥n <code>hrtimer_interrupt</code> es el manejador de las interrupciones del timer (revisaremos su c√≥digo m√°s adelante).</p>
<p>Otra forma de verificar qu√© manejador se utilizar√°, es revisar el archivo de solo lectura <code>/proc/timer_list</code> que contiene la lista de timers pendientes y los Clock Event devices.</p>
<p>En mi caso, valid√© que el manejador de estos dispositivos en mi m√°quina es efectivamente la funci√≥n <code>hrtimer_interrup</code>.</p>
<pre tabindex="0"><code># /proc/timer_list
....

Tick Device: mode:     1
Per CPU device: 0
Clock Event Device: lapic-deadline
 max_delta_ns:   1916620707137
 min_delta_ns:   1000
 mult:           9624619
 shift:          25
 mode:           3
 next_event:     14403083615478 nsecs
 set_next_event: lapic_next_deadline
 shutdown: lapic_timer_shutdown
 periodic: lapic_timer_set_periodic
 oneshot:  lapic_timer_set_oneshot
 oneshot stopped: lapic_timer_shutdown
 event_handler:  hrtimer_interrupt              &lt;&lt;&lt;&lt;&lt;&lt;&lt; the interrupt handler
 retries:        1316

Tick Device: mode:     1
Per CPU device: 1
Clock Event Device: lapic-deadline
 max_delta_ns:   1916620707137
 min_delta_ns:   1000
 mult:           9624619
 shift:          25
 mode:           3
 next_event:     14403083615478 nsecs
 set_next_event: lapic_next_deadline
 shutdown: lapic_timer_shutdown
 periodic: lapic_timer_set_periodic
 oneshot:  lapic_timer_set_oneshot
 oneshot stopped: lapic_timer_shutdown
 event_handler:  hrtimer_interrupt              &lt;&lt;&lt;&lt;&lt;&lt;&lt; the interrupt handler
 retries:        484
.... The rest of devices per CPU of my machine
</code></pre><p>Ahora que tenemos una idea de los High Resolution Timers y que la CPU tiene un timer de hardware que peri√≥dicamente causa interrupciones al kernel, podemos continuar con la syscall <code>nanosleep</code>.</p>
<h3 id="implementaci√≥n-de-la-syscall-nanosleep-en-linux">Implementaci√≥n de la syscall <code>nanosleep</code> en Linux</h3>
<blockquote>
<p>El Kernel de Linux es un proyecto enorme, miles de archivos y millones de l√≠neas de c√≥digo, navegar a trav√©s de ellos puede ser todo un desaf√≠o. Hay una herramienta online llamada LXR que ayuda a navegar el c√≥digo fuente del Kernel de Linux de manera amigable. La URL del sitio es <a href="https://elixir.bootlin.com/linux">https://elixir.bootlin.com/linux/5.14/source</a>.</p>
</blockquote>
<p>Hasta ahora sabemos que la syscall <code>nanosleep</code> hace toda la magia para mover el estado del proceso de Running a Sleeping durante un determinado n√∫mero de segundos, luego pasar al estado Running nuevamente. Ahora exploraremos el c√≥digo fuente del kernel de Linux y revisaremos cu√°les son los mecanismos internos detr√°s de ese comportamiento &ldquo;simple&rdquo;.</p>
<p>Primero, tenemos que verificar d√≥nde est√° definida la syscall <code>nanosleep</code>. Despu√©s de buscar un poco en Google, encontr√© un documento que especifica c√≥mo <a href="https://www.kernel.org/doc/html/latest/process/adding-syscalls.html#generic-system-call-implementation">se definen las syscall</a> en el kernel de Linux. Por lo tanto, tenemos que buscar <code>SYSCALL_DEFINE2(nanosleep, ....)</code>, el <code>2</code> en <code>SYSCALL_DEFINE2</code> indica el n√∫mero de argumentos de la syscall. S√© que <code>nanosleep</code> tiene dos argumentos despu√©s de comprobar en su <a href="https://man7.org/linux/man-pages/man2/nanosleep.2.html">manual</a> (todas las syscall tienen una p√°gina man(2)).</p>
<p>Despu√©s de buscar el t√©rmino <code>nanosleep</code> en LXR, encontr√© que la syscall est√° definida en archivo <a href="https://elixir.bootlin.com/linux/5.14/source/kernel/time/hrtimer.c#L1970">kernel/time/hrtimer.c</a> .</p>
<pre tabindex="0"><code>SYSCALL_DEFINE2(nanosleep, struct __kernel_timespec __user *, rqtp,
    struct __kernel_timespec __user *, rmtp)
{
  struct timespec64 tu;

  if (get_timespec64(&amp;tu, rqtp))
    return -EFAULT;

  if (!timespec64_valid(&amp;tu))
    return -EINVAL;

  current-&gt;restart_block.nanosleep.type = rmtp ? TT_NATIVE : TT_NONE;
  current-&gt;restart_block.nanosleep.rmtp = rmtp;
  return hrtimer_nanosleep(timespec64_to_ktime(tu), HRTIMER_MODE_REL,
         CLOCK_MONOTONIC);
}
</code></pre><p>Por supuesto, cada l√≠nea de c√≥digo tiene su raz√≥n de ser, pero resaltar√© la llamada a <code>timespec64_to_ktime</code> que convierte los argumentos de entrada de la syscall en la estructura <code>ktime</code> que es utilizada por el framework de High Resolution Timers. Finalmente, llama a la funci√≥n <code>hrtimer_nanosleep</code> donde comienza toda la diversi√≥n.</p>
<p>Ir√© funci√≥n por funci√≥n en el orden en que son llamadas y explicar√© las partes que considero relevantes:</p>
<p>La funci√≥n <a href="https://elixir.bootlin.com/linux/5.14/source/kernel/time/hrtimer.c#L1935">hrtimer_nanosleep</a>:</p>
<pre tabindex="0"><code>long hrtimer_nanosleep(ktime_t rqtp, const enum hrtimer_mode mode, const clockid_t clockid)
{
  ...
  hrtimer_init_sleeper_on_stack(&amp;t, clockid, mode);
  hrtimer_set_expires_range_ns(&amp;t.timer, rqtp, slack);
  ret = do_nanosleep(&amp;t, mode);
  ...
}
</code></pre><p>Hay tres partes relevantes aqu√≠:</p>
<ul>
<li>La inicializaci√≥n del High Resolution Timer (lo revisaremos m√°s adelante)</li>
<li>El tiempo de expiraci√≥n del timer inicializado. Aunque parece una tarea simple, hay mucha l√≥gica por debajo. Debido a que el Kernel de Linux funciona a nivel de hardware, para convertir el tiempo humano en tiempo de computadora tiene que usar algunas f√≥rmulas que se basan en la constante HZ que var√≠a seg√∫n la arquitectura. Adem√°s, aparece el concepto de <a href="https://en.wikipedia.org/wiki/Jiffy_(time)">Jiffies</a>. No entrar√© en m√°s detalles, sin embargo <a href="#references">[4]</a> explica muy bien esta parte.</li>
<li>Finalmente, llama a la funci√≥n <code>do_nanosleep</code> que tiene la l√≥gica que env√≠a un proceso a dormir.</li>
</ul>
<p>La funci√≥n <a href="https://elixir.bootlin.com/linux/5.14/source/kernel/time/hrtimer.c#L442">hrtimer_init_sleeper_on_stack</a> (que al final llama a <a href="https://elixir.bootlin.com/linux/5.14/source/kernel/time/hrtimer.c#L1821">__hrtimer_init_sleeper</a>) asigna e inicializa un High Resolution Timer asociado con el proceso actual que se est√° ejecutando.</p>
<p>El atributo <code>function</code> del High Resolution Sleep Timer es la funci√≥n callback, lo que significa que este atributo <code>function</code> se llamar√° despu√©s de que expire el High Resolution Timer. En este caso el valor del <a href="https://elixir.bootlin.com/linux/v5.14/source/kernel/time/hrtimer.c#L1849">atributo function</a> es la funci√≥n <code>hrtimer_wakeup</code> que veremos m√°s adelante (no se olviden de esto üòâ).</p>
<pre tabindex="0"><code>static void __hrtimer_init_sleeper(struct hrtimer_sleeper *sl,
          clockid_t clock_id, enum hrtimer_mode mode)
{
  ...
  __hrtimer_init(&amp;scicil-&gt;timer, clock_id, mode);
  sl-&gt;timer.function = hrtimer_wakeup; // &lt;&lt;&lt;&lt;&lt;&lt; This function will be called after the timer expires
  sl-&gt;task = current;                  // &lt;&lt;&lt;&lt;&lt;&lt; Associates the timer with the current process
}
</code></pre><blockquote>
<p>En el kernel de Linux, la variable <code>current</code> es un puntero al proceso actual que se est√° ejecutando (en nuestro caso, el programa que llama a la funci√≥n <code>sleep</code>).</p>
</blockquote>
<p>Antes de continuar con la funci√≥n <code>do_nanosleep</code>, har√© un par√©ntesis sobre la funci√≥n <a href="https://elixir.bootlin.com/linux/5.14/source/kernel/time/hrtimer.c#L1393">__hrtimer_init</a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__hrtimer_init</span>(<span style="color:#66d9ef">struct</span> hrtimer <span style="color:#f92672">*</span>timer, <span style="color:#66d9ef">clockid_t</span> clock_id,
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">enum</span> hrtimer_mode mode)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">timerqueue_init</span>(<span style="color:#f92672">&amp;</span>timer<span style="color:#f92672">-&gt;</span>node);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Mencion√© que los High Resolution Timers usan una cola que por debajo es implementada utilizando un Red Black Tree. La llamada a las funciones <a href="https://elixir.bootlin.com/linux/5.14/source/include/linux/timerqueue.h#L43">timerqueue_init</a> solo asigna e inicializa un nodo del Red Black Tree, sin embargo este nodo no es agregado al √°rbol a√∫n.</p>
<p>Despu√©s de ese breve par√©ntesis, veamos qu√© sucede dentro de la funci√≥n <a href="https://elixir.bootlin.com/linux/5.14/source/kernel/time/hrtimer.c#L1887">do_nanosleep</a>.</p>
<p>Inicialmente pens√© que el ciclo do/while itera hasta que High Resolution Timer expire (algo como un bucle infinito), sin embargo las cosas suceden de manera diferente.</p>
<pre tabindex="0"><code>static int __sched do_nanosleep(struct hrtimer_sleeper *t, enum hrtimer_mode mode)
{
  struct restart_block *restart;

  do {
    set_current_state(TASK_INTERRUPTIBLE);   // &lt;&lt;&lt;&lt; This causes the process to go to a Sleeping state
    hrtimer_sleeper_start_expires(t, mode);

    if (likely(t-&gt;task))
      freezable_schedule();

    hrtimer_cancel(&amp;t-&gt;timer);
    mode = HRTIMER_MODE_ABS;

  } while (t-&gt;task &amp;&amp; !signal_pending(current));

  __set_current_state(TASK_RUNNING);

  if (!t-&gt;task)
    return 0;

  restart = &amp;current-&gt;restart_block;
  if (restart-&gt;nanosleep.type != TT_NONE) {
    ktime_t rem = hrtimer_expires_remaining(&amp;t-&gt;timer);
    struct timespec64 rmt;

    if (rem &lt;= 0)
      return 0;
    rmt = ktime_to_timespec64(rem);

    return nanosleep_copyout(restart, &amp;rmt);
  }
  return -ERESTART_RESTARTBLOCK;
}
</code></pre><p>Como se mencion√≥ anteriormente, cuando se llama a la funci√≥n <code>sleep</code>, el proceso actual pasar√° al estado <code>Sleeping</code>. Podemos ver que eso sucede en la l√≠nea que llama a la funci√≥n <code>set_current_state</code> que cambia el estado del proceso actual a <code>TASK_INTERRUPTIBLE</code> (Sleeping).</p>
<p>La llamada a la funci√≥n <a href="https://elixir.bootlin.com/linux/5.14/source/kernel/time/hrtimer.c#L1804">hrtimer_sleeper_start_expires</a> llamar√° a otras funciones hasta que llame a <a href="https://elixir.bootlin.com/linux/5.14/source/kernel/time/hrtimer.c#L1101">__hrtimer_start_range_ns</a> que a su vez llamar√° a <code>enqueue_hrtimer</code>, es en este punto donde el timer (nodo) inicializado antes se agrega a la estructura del Red Black Tree para que el timer pueda ser procesado m√°s tarde.</p>
<p>Finalmente, la funci√≥n <code>freezable_schedule</code> invoca al process scheduler para que haga schedule de otro proceso, porque el proceso actual <code>current</code> entr√≥ en suspensi√≥n y la ejecuci√≥n de nuestro proceso se detiene aqu√≠.</p>
<h4 id="c√≥mo-despierta-el-proceso">C√≥mo Despierta El Proceso?</h4>
<p>Hasta ahora hemos comprobado que la implementaci√≥n de <code>nanosleep</code> cambia el estado del proceso a <code>TASK_INTERRUPTIBLE</code> y pausa la ejecuci√≥n del proceso.</p>
<p>Ahora que el estado del proceso est√° en el estado <code>TASK_INTERRUPTIBLE</code>, el process scheduler no considerar√° la ejecuci√≥n del proceso hasta que el estado del proceso vuelva a <code>TASK_RUNNING</code>.</p>
<p>Mencionamos que el <a href="#hardware-timer">Hardware Timer</a> causa interrupciones peri√≥dicas para que el Kernel de Linux pueda manejarlas llamando a la funci√≥n <a href="https://elixir.bootlin.com/linux/5.14/source/kernel/time/hrtimer.c#L1633">hrtimer_interrupt</a> en cada interrupci√≥n (varias veces en un segundo). Es en esta funci√≥n donde se procesan los High Resolution Timers llamando a la funci√≥n <a href="https://elixir.bootlin.com/linux/5.14/source/kernel/time/hrtimer.c#L1569">__hrtimer_run_queues</a>.</p>
<pre tabindex="0"><code>static void __hrtimer_run_queues(struct hrtimer_cpu_base *cpu_base, ktime_t now,
         unsigned long flags, unsigned int active_mask)
{
  struct hrtimer_clock_base *base;
  unsigned int active = cpu_base-&gt;active_bases &amp; active_mask;

  for_each_active_base(base, cpu_base, active) {
    struct timerqueue_node *node;
    ktime_t basenow;

    basenow = ktime_add(now, base-&gt;offset);

    while ((node = timerqueue_getnext(&amp;base-&gt;active))) {
      struct hrtimer *timer;

      timer = container_of(node, struct hrtimer, node);
      if (basenow &lt; hrtimer_get_softexpires_tv64(timer))
        break;

      __run_hrtimer(cpu_base, base, timer, &amp;basenow, flags);
      if (active_mask == HRTIMER_ACTIVE_SOFT)
        hrtimer_sync_wait_running(cpu_base, flags);
    }
  }
}
</code></pre><p>La funci√≥n <code>__hrtimer_run_queues</code> iterar√° los timers en el Red Black Tree, recuerden que iterar√° comenzando por los timers que est√°n m√°s pr√≥ximos a expirar. Algo a tener en cuenta aqu√≠ es que romper√° el ciclo while si el timer a√∫n no ha expirado (¬øpor qu√© tener iteraciones innecesarias si el header de la cola es un timer que no ha caducado a√∫n?). Pero cuando el timer expire, llamar√° a la funci√≥n <a href="https://elixir.bootlin.com/linux/5.14/source/kernel/time/hrtimer.c#L1494">__run_hrtimer</a>. Como podemos ver, su implementaci√≥n llamar√° al callback que configuramos durante la inicializaci√≥n del High Resolution Timer.</p>
<pre tabindex="0"><code>static void __run_hrtimer(struct hrtimer_cpu_base *cpu_base,
        struct hrtimer_clock_base *base,
        struct hrtimer *timer, ktime_t *now,
        unsigned long flags) __must_hold(&amp;cpu_base-&gt;lock)
{
  ...
  fn = timer-&gt;function; // &lt;&lt;&lt;&lt;&lt; This fn function is pointing to the hrtimer_wakeup function
  ...
  restart = fn(timer);
  ...
}
</code></pre><p>La funci√≥n que se configur√≥ como el callback durante la inicializaci√≥n del High Resolution Timer fue la funci√≥n <a href="https://elixir.bootlin.com/linux/5.14/source/kernel/time/hrtimer.c#L1783">hrtimer_wakeup</a>.</p>
<pre tabindex="0"><code>static enum hrtimer_restart hrtimer_wakeup(struct hrtimer *timer)
{
  struct hrtimer_sleeper *t =
    container_of(timer, struct hrtimer_sleeper, timer);
  struct task_struct *task = t-&gt;task;

  t-&gt;task = NULL;
  if (task)
    wake_up_process(task);    // &lt;&lt;&lt;&lt;&lt;&lt; Wake up the process!!

  return HRTIMER_NORESTART;
}
</code></pre><p>Como podemos ver, esta funci√≥n llamar√° a la funci√≥n <code>wake_up_process</code> enviando el proceso (tarea) asociado con el High Resolution Timer como par√°metro. La funci√≥n <code>wake_up_process</code>, entre otras cosas, establecer√° el estado del proceso en <code>TASK_RUNNING</code>.</p>
<p>Algunos ciclos de CPU m√°s tarde, el process schduler reanudar√° la ejecuci√≥n de nuestro proceso donde se detuvo (despu√©s de la llamada a la funci√≥n <code>freezable_schedule</code>). Luego, el resto de la funci√≥n <code>do_nanosleep</code> liberar√° memoria, eliminar√° el timer del Red Black Tree y continuar√° con la ejecuci√≥n. ¬°Y eso es todo!</p>
<h3 id="hay-otras-alternativas-a-nanosleep">Hay otras alternativas a <code>nanosleep</code></h3>
<p>La syscall <code>nanosleep</code> no es la √∫nica syscall que se puede usar para dormir un proceso. Por ejemplo, la funci√≥n <code>time.sleep</code> de Python usa la syscall <code>select</code> por detr√°s, sin embargo, si revisamos la implementaci√≥n de <a href="https://elixir.bootlin.com/linux/5.14/source/fs/select.c#L476">do_select</a> que a su vez llama a la funci√≥n <a href="https://elixir.bootlin.com/linux/5.14/source/fs/select.c#L236">schedule_hrtimeout_range</a>, se nota que llama a la funci√≥n <code>schedule_hrtimeout_range</code> que inicializa un High Resolution Timer y le dice al process scheduler que haga schedule de otro proceso (la misma l√≥gica que con <code>nanosleep</code>).</p>
<p>Python <code>sleep</code> es un ejemplo, pero otros lenguajes posiblemente usan otras syscalls.</p>
<h3 id="comentarios-finales">Comentarios Finales</h3>
<p>Aunque llamar a la funci√≥n <code>sleep</code> en nuestros programas puede ser algo trivial, todos los mecanismos que viven detr√°s de esa simple funci√≥n son asombrosos. Cuando comenc√© a investigar para entender qu√© sucede cuando llamas a una funci√≥n <code>sleep</code>, no me hubiera imaginado cu√°nto iba a aprender.</p>
<p>En caso de que haya partes de este post que sean incorrectas, puedenm abrir un issue en el <a href="https://github.com/donkeysharp/donkeysharp.github.io">repositorio de Github</a> de este blog. ¬°Muchas gracias!.</p>
<h2 id="referencias">Referencias</h2>
<ul>
<li>[0] <a href="https://lwn.net/Articles/167897/">https://lwn.net/Articles/167897/</a></li>
<li>[1] <a href="https://lwn.net/Articles/152436/">https://lwn.net/Articles/152436/</a></li>
<li>[2] <a href="https://www.kernel.org/doc/html/latest/timers/hrtimers.html">https://www.kernel.org/doc/html/latest/timers/hrtimers.html</a></li>
<li>[3] <a href="https://www.kernel.org/doc/html/latest/timers/highres.html">https://www.kernel.org/doc/html/latest/timers/highres.html</a></li>
<li>[4] <a href="https://www.youtube.com/watch?v=Puv4mW55bF8">https://www.youtube.com/watch?v=Puv4mW55bF8</a></li>
</ul>


        

        

        
          

          
        
      </article>

      
        <ul class="pager blog-pager">
          
            <li class="previous">
              <a href="https://blog.donkeysharp.xyz/es/post/gracias-profe-elias/" data-toggle="tooltip" data-placement="top" title="Gracias Profe Elias">&larr; Art√≠culo anterior</a>
            </li>
          
          
            <li class="next">
              <a href="https://blog.donkeysharp.xyz/es/mock-ec2-metadata/" data-toggle="tooltip" data-placement="top" title="Simulando servidor de metadata de EC2 localmente">Art√≠culo siguiente &rarr;</a>
            </li>
          
        </ul>
      


      
        
        
      

    </div>
  </div>
</div>

    
<footer>
<div class="container">
<div class="row">
  <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
    <ul class="list-inline text-center footer-links">
      
          <li>
            <a target="_blank" href="https://github.com/donkeysharp" title="GitHub">
              <span class="fa-stack fa-lg">
                <i class="fas fa-circle fa-stack-2x"></i>
                <i class="fab fa-github fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          <li>
            <a target="_blank" href="https://twitter.com/donkeysharp" title="Twitter">
              <span class="fa-stack fa-lg">
                <i class="fas fa-circle fa-stack-2x"></i>
                <i class="fab fa-twitter fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          <li>
            <a target="_blank" href="https://www.instagram.com/donkeysharp" title="Instagram">
              <span class="fa-stack fa-lg">
                <i class="fas fa-circle fa-stack-2x"></i>
                <i class="fab fa-instagram fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
      
      <li>
        <a target="_blank" href="" title="RSS">
          <span class="fa-stack fa-lg">
            <i class="fas fa-circle fa-stack-2x"></i>
            <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
          </span>
        </a>
      </li>
      
    </ul>
    <p class="credits copyright text-muted">
      
        
          Sergio Guillen
        
      
      &bull;
      
        2025
      
    </p>
    
    <p class="credits theme-by text-muted">
      Creado con <a target="_" href="https://gohugo.io">Hugo</a>.
&nbsp;&bull;&nbsp;
Tema <a target="_" href="https://github.com/halogenica/beautifulhugo">Beautiful Hugo</a>

      
    </p>
  </div>
</div>
</div>
</footer><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/contrib/auto-render.min.js" integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe" crossorigin="anonymous"></script>
<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<script src="https://blog.donkeysharp.xyz/js/main.js"></script>
<script src="https://blog.donkeysharp.xyz/js/highlight.min.js"></script>
<script> hljs.initHighlightingOnLoad(); </script>
<script> $(document).ready(function() {$("pre.chroma").css("padding","0");}); </script><script> renderMathInElement(document.body); </script><script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js" integrity="sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js" integrity="sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q" crossorigin="anonymous"></script><script src="https://blog.donkeysharp.xyz/js/load-photoswipe.js"></script>









    
  </body>
</html>

