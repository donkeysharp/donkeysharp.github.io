<!DOCTYPE html>
<html lang="es" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Qu√© sucede cuando un proceso de Linux se va a dormir? | Donkeysharp</title>
<meta name="keywords" content="">
<meta name="description" content="Es posible que cuando estas escribiendo un programa, en alg√∫n momento necesites pausar la ejecuci√≥n de un proceso llamando a la funci√≥n sleep(NUMBER_OF_SECONDS) dependiendo del problema que est√©s resolviendo. En este post, compartir√© lo que aprend√≠ hasta ahora mientras investigaba los mecanismos internos del kernel que hacen que la funci√≥n sleep funcione de la forma en que lo hace.

Agradezco su feedback. No soy un experto en este tema ya que las partes internas del Kernel de Linux son nuevas para m√≠, fue solo mi curiosidad lo que me llev√≥ a revisar el c√≥digo fuente del Kernel y quer√≠a compartir lo que aprend√≠. Si encuentran algo incorrecto en este post, pueden abrir un issue en el repositorio de Github de este blog. Gracias!.">
<meta name="author" content="donkeysharp">
<link rel="canonical" href="https://blog.donkeysharp.xyz/es/post/what-happens-when-a-process-goes-to-sleep/">
<meta name="google-site-verification" content="G-NE86EKXE5N">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7f710067e04dcceea91964a3f3e88a29f286096ac5fb3cb6541ffb78d592b3eb.css" integrity="sha256-f3EAZ&#43;BNzO6pGWSj8&#43;iKKfKGCWrF&#43;zy2VB/7eNWSs&#43;s=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://blog.donkeysharp.xyz/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://blog.donkeysharp.xyz/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://blog.donkeysharp.xyz/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://blog.donkeysharp.xyz/apple-touch-icon.png">
<link rel="mask-icon" href="https://blog.donkeysharp.xyz/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://blog.donkeysharp.xyz/post/what-happens-when-a-process-goes-to-sleep/">
<link rel="alternate" hreflang="es" href="https://blog.donkeysharp.xyz/es/post/what-happens-when-a-process-goes-to-sleep/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NE86EKXE5N"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-NE86EKXE5N');
</script>
<meta property="og:url" content="https://blog.donkeysharp.xyz/es/post/what-happens-when-a-process-goes-to-sleep/">
  <meta property="og:site_name" content="Donkeysharp">
  <meta property="og:title" content="Qu√© sucede cuando un proceso de Linux se va a dormir?">
  <meta property="og:description" content="Es posible que cuando estas escribiendo un programa, en alg√∫n momento necesites pausar la ejecuci√≥n de un proceso llamando a la funci√≥n sleep(NUMBER_OF_SECONDS) dependiendo del problema que est√©s resolviendo. En este post, compartir√© lo que aprend√≠ hasta ahora mientras investigaba los mecanismos internos del kernel que hacen que la funci√≥n sleep funcione de la forma en que lo hace.
Agradezco su feedback. No soy un experto en este tema ya que las partes internas del Kernel de Linux son nuevas para m√≠, fue solo mi curiosidad lo que me llev√≥ a revisar el c√≥digo fuente del Kernel y quer√≠a compartir lo que aprend√≠. Si encuentran algo incorrecto en este post, pueden abrir un issue en el repositorio de Github de este blog. Gracias!.">
  <meta property="og:locale" content="es">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-03-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2022-03-10T00:00:00+00:00">
      <meta property="og:image" content="https://blog.donkeysharp.xyz/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://blog.donkeysharp.xyz/images/papermod-cover.png">
<meta name="twitter:title" content="Qu√© sucede cuando un proceso de Linux se va a dormir?">
<meta name="twitter:description" content="Es posible que cuando estas escribiendo un programa, en alg√∫n momento necesites pausar la ejecuci√≥n de un proceso llamando a la funci√≥n sleep(NUMBER_OF_SECONDS) dependiendo del problema que est√©s resolviendo. En este post, compartir√© lo que aprend√≠ hasta ahora mientras investigaba los mecanismos internos del kernel que hacen que la funci√≥n sleep funcione de la forma en que lo hace.

Agradezco su feedback. No soy un experto en este tema ya que las partes internas del Kernel de Linux son nuevas para m√≠, fue solo mi curiosidad lo que me llev√≥ a revisar el c√≥digo fuente del Kernel y quer√≠a compartir lo que aprend√≠. Si encuentran algo incorrecto en este post, pueden abrir un issue en el repositorio de Github de este blog. Gracias!.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://blog.donkeysharp.xyz/es/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Qu√© sucede cuando un proceso de Linux se va a dormir?",
      "item": "https://blog.donkeysharp.xyz/es/post/what-happens-when-a-process-goes-to-sleep/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Qu√© sucede cuando un proceso de Linux se va a dormir?",
  "name": "Qu√© sucede cuando un proceso de Linux se va a dormir?",
  "description": "Es posible que cuando estas escribiendo un programa, en alg√∫n momento necesites pausar la ejecuci√≥n de un proceso llamando a la funci√≥n sleep(NUMBER_OF_SECONDS) dependiendo del problema que est√©s resolviendo. En este post, compartir√© lo que aprend√≠ hasta ahora mientras investigaba los mecanismos internos del kernel que hacen que la funci√≥n sleep funcione de la forma en que lo hace.\nAgradezco su feedback. No soy un experto en este tema ya que las partes internas del Kernel de Linux son nuevas para m√≠, fue solo mi curiosidad lo que me llev√≥ a revisar el c√≥digo fuente del Kernel y quer√≠a compartir lo que aprend√≠. Si encuentran algo incorrecto en este post, pueden abrir un issue en el repositorio de Github de este blog. Gracias!.\n",
  "keywords": [
    
  ],
  "articleBody": "Es posible que cuando estas escribiendo un programa, en alg√∫n momento necesites pausar la ejecuci√≥n de un proceso llamando a la funci√≥n sleep(NUMBER_OF_SECONDS) dependiendo del problema que est√©s resolviendo. En este post, compartir√© lo que aprend√≠ hasta ahora mientras investigaba los mecanismos internos del kernel que hacen que la funci√≥n sleep funcione de la forma en que lo hace.\nAgradezco su feedback. No soy un experto en este tema ya que las partes internas del Kernel de Linux son nuevas para m√≠, fue solo mi curiosidad lo que me llev√≥ a revisar el c√≥digo fuente del Kernel y quer√≠a compartir lo que aprend√≠. Si encuentran algo incorrecto en este post, pueden abrir un issue en el repositorio de Github de este blog. Gracias!.\nProcess State Uno de los primeros conceptos que necesitamos revisar es el estado de un proceso. Un proceso en Linux tiene un estado asociado que representa su estado de ejecuci√≥n en el sistema operativo. Un proceso puede estar en uno de los siguientes estados:\nRunning Sleeping (interruptible and uninterruptible) Stopped Zombie Cuando un proceso est√° ejecutando instrucciones en la CPU, se encuentra en estado ‚ÄúRunning‚Äù y cuando el proceso est√° esperando que suceda algo, es decir, esperando I/O de red o disco, o se llama a la funcion sleep, cambiar√° a un estado Sleeping.\nPodemos comprobarlo con un sencillo programa de ejemplo en C:\n// states.c // gcc states.c -o states #include #include #define SOME_MAGIC_NUMBER 365000000l void start_processing() { long i; printf(\"Starting Loop\\n\"); for (i = 0; i \u003c (long)(10 * SOME_MAGIC_NUMBER); i++); printf(\"Loop Finished\\n\"); } int main() { pid_t pid = getpid(); printf(\"PID: %d\\n\", pid); start_processing(); printf(\"Sleep process\\n\"); sleep(5); printf(\"Sleep finished\\n\"); start_processing(); return 0; } El c√≥digo anterior ejecutar√° un loop durante algunos segundos, luego se suspender√° durante 5 segundos y finalmente ejecutar√° otro loop durante otro n√∫mero de segundos. Por lo tanto, esperamos que el estado del proceso sea Running -\u003e Sleeping -\u003e Running.\nMientras se ejecuta el programa, podemos comprobar el estado del proceso con la herramienta Htop, que normalmente mostrar√° una letra en la octava columna que representa el estado del proceso, e.g. R (Running), S (Sleeping), T (Stopped), etc.\nComo era de esperar, los estados que ten√≠a el proceso durante la ejecuci√≥n fueron: Running (R) -\u003e Sleeping (S) -\u003e Running (R).\nTL;DR (super resumido) Cuando un programa llama a la funci√≥n sleep(NUMBER_OF_SECONDS) (en C), este usar√° la llamada al sistema (syscall) nanosleep. Otros lenguajes de programaci√≥n usan diferentes syscalls que tambi√©n pueden enviar un proceso a dormir durante algunos segundos, e.g. select.\nLa implementaci√≥n del kernel de Linux de la syscall nanosleep har√° lo siguiente:\nInicializar un High Resolution sleep timer. Cambiar el estado del proceso a TASK_INTERRUPTIBLE (Sleeping). Inicia el High Resolution sleep timer. Indicar al scheduler de procesos para poner a otro proceso en ejecuci√≥n y pausar la ejecuci√≥n del proceso actual. El kernel de Linux procesa los High Resolution Timers de la siguiente manera:\nEl hardware de la computadora tiene un CPU timer que causa interrupciones peri√≥dicamente, haciendo que el kernel las maneje llamando a la funci√≥n hrtimer_interrupt. La funci√≥n hrtimer_interrupt procesar√° los High Resolution Timers (a nivel de software) existentes y ver√° si un timer expir√≥. Una vez que un High Resolution Timer expire, el kernel llamar√° a la funci√≥n hrtimer_wakeup que activar√° el proceso asociado con el timer, y eso cambiar√° el estado de TASK_INTERRUPTIBLE (Sleeping) a TASK_RUNNING (Running). Finalmente, algunos ciclos de CPU m√°s tarde, el scheduler de procesos continuar√° la ejecuci√≥n del proceso exactamente donde se detuvo. Sigue leyendo si est√° interesado en m√°s detalles.\nYendo M√°s A Fondo Como ingenieros de software, es probable que la mayor parte del tiempo estemos escribiendo aplicaciones que se ejecutan en user space o user mode, como servidores (de cualquier tipo) o aplicaciones del lado del servidor, web , aplicaciones m√≥viles o de escritorio, scripts de automatizaci√≥n, etc.\nNo importa el lenguaje de programaci√≥n, el framework o la tecnolog√≠a, internamente un programa que se ejecuta en user mode siempre interactuar√° de una forma u otra con el sistema operativo (en este post Linux) a trav√©s de System Calls o syscalls. Por ejemplo, cuando leemos un archivo, nuestro c√≥digo (sin importar el lenguaje de programaci√≥n) se comunicar√° indirectamente con el Kernel de Linux a trav√©s de la syscall read (no es la √∫nica), luego el kernel le pedir√° al disco duro f√≠sico el contenido del archivo que queremos basado en el sistema de archivos, y finalmente devolver√° el contenido solicitado a nuestro programa.\nHay una herramienta llamada Strace que monitorea todas las syscall que ejecuta un proceso.\nSi ejecutamos el ejemplo anterior en C usando strace, podemos ver la siguiente salida:\n$ strace ./states ... syscalls for process loading (they won't be useful right now) ... write(1, \"PID: 26846\\n\", 11PID: 26846 ) = 11 write(1, \"Starting Loop\\n\", 14Starting Loop ) = 14 write(1, \"Loop Finished\\n\", 14Loop Finished ) = 14 write(1, \"Sleep process\\n\", 14Sleep process ) = 14 nanosleep({tv_sec=5, tv_nsec=0}, 0x7ffefc933be0) = 0 write(1, \"Sleep finished\\n\", 15Sleep finished ) = 15 write(1, \"Starting Loop\\n\", 14Starting Loop ) = 14 write(1, \"Loop Finished\\n\", 14Loop Finished ) = 14 exit_group(0) = ? +++ exited with 0 +++ La salida verdadera es m√°s larga que la que se muestra arriba, pero la mayor√≠a de las primeras syscalls siempre se ejecutan cuando se inicia un proceso y carga la biblioteca est√°ndar de C entre otras cosas, pero las que nos interesa revisar son las √∫ltimas.\nLa syscall write le dice al Kernel que el programa quiere mostrar una cadena de texto en la salida est√°ndar (en este caso la terminal). Con esa informaci√≥n, podemos tener una idea de que la funci√≥n printf se comunica con el sistema operativo llamando a la syscall write.\nLuego se llama a la syscall nanosleep, que indicar√° al kernel de Linux que mueva el proceso de un estado Running a un estado Sleeping.\nAntes de revisar la implementaci√≥n en Linux de la syscall nanosleep, primero tenemos que revisar un par de conceptos para tener una mejor comprensi√≥n de lo que viene.\nHigh Resolution Timers Dentro del kernel de Linux, diferentes componentes deben esperar un tiempo antes de ejecutar algo, aqu√≠ es donde entra el concepto de Timers. Un timer es una estructura (struct) en la que definimos su tiempo de expiraci√≥n (el tiempo de espera) y qu√© funci√≥n se llamar√° una vez que el timer expira.\nEl kernel de Linux tiene dos tipos de timers: Low Resolution Timers y High Resolution Timers. Revisaremos los Hight Resolution Timers.\nEl framework detr√°s de los High Resolution Timers dentro del kernel de Linux es un conjunto de structs y funciones que procesan los timers de manera √≥ptima. Su implementaci√≥n se basa en una cola de timers que se ordenan por el timer que expirar√° m√°s pronto. Para que esta cola sea eficiente, utiliza la estructura de datos Red Black Tree para que la inserci√≥n y la eliminaci√≥n se puedan realizar en tiempo logar√≠tmico.\nEste framework es muy interesante como tal, en este art√≠culo solo revisaremos c√≥mo se usa y algunas partes espec√≠ficas de su implementaci√≥n. Para obtener m√°s informaci√≥n sobre los detalles de implementaci√≥n, lea [0], [1] y [2].\nLa gesti√≥n del tiempo o time management dentro del kernel de Linux es un tema muy interesante y la charla dada por Stephen Boyd titulada ‚ÄúTimekeeping In The Linux Kernel‚Äù [4] me dio una mejor comprensi√≥n de c√≥mo el Kernel de Linux maneja las tareas relacionadas al tiempo, as√≠ como su complejidad. Esta charla me ayud√≥ mucho. ¬°Gracias!\nHardware Timer La CPU (f√≠sicamente) tiene un reloj e internamente tiene un timer programable. En palabras simples, el objetivo principal de este timer es causar interrupciones peri√≥dicamente (muchas veces dentro de un segundo) para que el kernel pueda manejarlas. La frecuencia de estas interrupciones depender√° de la arquitectura que se especifique en el Kernel de Linux durante su compilaci√≥n. El kernel de Linux abstrae esto como Clock Event Devices y hay un Clock Event Device por CPU. Se utiliza un Clock Event Device para programar la siguiente interrupci√≥n que se generar√° [3].\nCuando ocurre una interrupci√≥n del timer, el kernel de Linux lo manejar√° llamando a una funci√≥n. [4] menciona que para los High Resolution Timers, la funci√≥n hrtimer_interrupt es el manejador de las interrupciones del timer (revisaremos su c√≥digo m√°s adelante).\nOtra forma de verificar qu√© manejador se utilizar√°, es revisar el archivo de solo lectura /proc/timer_list que contiene la lista de timers pendientes y los Clock Event devices.\nEn mi caso, valid√© que el manejador de estos dispositivos en mi m√°quina es efectivamente la funci√≥n hrtimer_interrup.\n# /proc/timer_list .... Tick Device: mode: 1 Per CPU device: 0 Clock Event Device: lapic-deadline max_delta_ns: 1916620707137 min_delta_ns: 1000 mult: 9624619 shift: 25 mode: 3 next_event: 14403083615478 nsecs set_next_event: lapic_next_deadline shutdown: lapic_timer_shutdown periodic: lapic_timer_set_periodic oneshot: lapic_timer_set_oneshot oneshot stopped: lapic_timer_shutdown event_handler: hrtimer_interrupt \u003c\u003c\u003c\u003c\u003c\u003c\u003c the interrupt handler retries: 1316 Tick Device: mode: 1 Per CPU device: 1 Clock Event Device: lapic-deadline max_delta_ns: 1916620707137 min_delta_ns: 1000 mult: 9624619 shift: 25 mode: 3 next_event: 14403083615478 nsecs set_next_event: lapic_next_deadline shutdown: lapic_timer_shutdown periodic: lapic_timer_set_periodic oneshot: lapic_timer_set_oneshot oneshot stopped: lapic_timer_shutdown event_handler: hrtimer_interrupt \u003c\u003c\u003c\u003c\u003c\u003c\u003c the interrupt handler retries: 484 .... The rest of devices per CPU of my machine Ahora que tenemos una idea de los High Resolution Timers y que la CPU tiene un timer de hardware que peri√≥dicamente causa interrupciones al kernel, podemos continuar con la syscall nanosleep.\nImplementaci√≥n de la syscall nanosleep en Linux El Kernel de Linux es un proyecto enorme, miles de archivos y millones de l√≠neas de c√≥digo, navegar a trav√©s de ellos puede ser todo un desaf√≠o. Hay una herramienta online llamada LXR que ayuda a navegar el c√≥digo fuente del Kernel de Linux de manera amigable. La URL del sitio es https://elixir.bootlin.com/linux/5.14/source.\nHasta ahora sabemos que la syscall nanosleep hace toda la magia para mover el estado del proceso de Running a Sleeping durante un determinado n√∫mero de segundos, luego pasar al estado Running nuevamente. Ahora exploraremos el c√≥digo fuente del kernel de Linux y revisaremos cu√°les son los mecanismos internos detr√°s de ese comportamiento ‚Äúsimple‚Äù.\nPrimero, tenemos que verificar d√≥nde est√° definida la syscall nanosleep. Despu√©s de buscar un poco en Google, encontr√© un documento que especifica c√≥mo se definen las syscall en el kernel de Linux. Por lo tanto, tenemos que buscar SYSCALL_DEFINE2(nanosleep, ....), el 2 en SYSCALL_DEFINE2 indica el n√∫mero de argumentos de la syscall. S√© que nanosleep tiene dos argumentos despu√©s de comprobar en su manual (todas las syscall tienen una p√°gina man(2)).\nDespu√©s de buscar el t√©rmino nanosleep en LXR, encontr√© que la syscall est√° definida en archivo kernel/time/hrtimer.c .\nSYSCALL_DEFINE2(nanosleep, struct __kernel_timespec __user *, rqtp, struct __kernel_timespec __user *, rmtp) { struct timespec64 tu; if (get_timespec64(\u0026tu, rqtp)) return -EFAULT; if (!timespec64_valid(\u0026tu)) return -EINVAL; current-\u003erestart_block.nanosleep.type = rmtp ? TT_NATIVE : TT_NONE; current-\u003erestart_block.nanosleep.rmtp = rmtp; return hrtimer_nanosleep(timespec64_to_ktime(tu), HRTIMER_MODE_REL, CLOCK_MONOTONIC); } Por supuesto, cada l√≠nea de c√≥digo tiene su raz√≥n de ser, pero resaltar√© la llamada a timespec64_to_ktime que convierte los argumentos de entrada de la syscall en la estructura ktime que es utilizada por el framework de High Resolution Timers. Finalmente, llama a la funci√≥n hrtimer_nanosleep donde comienza toda la diversi√≥n.\nIr√© funci√≥n por funci√≥n en el orden en que son llamadas y explicar√© las partes que considero relevantes:\nLa funci√≥n hrtimer_nanosleep:\nlong hrtimer_nanosleep(ktime_t rqtp, const enum hrtimer_mode mode, const clockid_t clockid) { ... hrtimer_init_sleeper_on_stack(\u0026t, clockid, mode); hrtimer_set_expires_range_ns(\u0026t.timer, rqtp, slack); ret = do_nanosleep(\u0026t, mode); ... } Hay tres partes relevantes aqu√≠:\nLa inicializaci√≥n del High Resolution Timer (lo revisaremos m√°s adelante) El tiempo de expiraci√≥n del timer inicializado. Aunque parece una tarea simple, hay mucha l√≥gica por debajo. Debido a que el Kernel de Linux funciona a nivel de hardware, para convertir el tiempo humano en tiempo de computadora tiene que usar algunas f√≥rmulas que se basan en la constante HZ que var√≠a seg√∫n la arquitectura. Adem√°s, aparece el concepto de Jiffies. No entrar√© en m√°s detalles, sin embargo [4] explica muy bien esta parte. Finalmente, llama a la funci√≥n do_nanosleep que tiene la l√≥gica que env√≠a un proceso a dormir. La funci√≥n hrtimer_init_sleeper_on_stack (que al final llama a __hrtimer_init_sleeper) asigna e inicializa un High Resolution Timer asociado con el proceso actual que se est√° ejecutando.\nEl atributo function del High Resolution Sleep Timer es la funci√≥n callback, lo que significa que este atributo function se llamar√° despu√©s de que expire el High Resolution Timer. En este caso el valor del atributo function es la funci√≥n hrtimer_wakeup que veremos m√°s adelante (no se olviden de esto üòâ).\nstatic void __hrtimer_init_sleeper(struct hrtimer_sleeper *sl, clockid_t clock_id, enum hrtimer_mode mode) { ... __hrtimer_init(\u0026scicil-\u003etimer, clock_id, mode); sl-\u003etimer.function = hrtimer_wakeup; // \u003c\u003c\u003c\u003c\u003c\u003c This function will be called after the timer expires sl-\u003etask = current; // \u003c\u003c\u003c\u003c\u003c\u003c Associates the timer with the current process } En el kernel de Linux, la variable current es un puntero al proceso actual que se est√° ejecutando (en nuestro caso, el programa que llama a la funci√≥n sleep).\nAntes de continuar con la funci√≥n do_nanosleep, har√© un par√©ntesis sobre la funci√≥n __hrtimer_init.\nstatic void __hrtimer_init(struct hrtimer *timer, clockid_t clock_id, enum hrtimer_mode mode) { ... timerqueue_init(\u0026timer-\u003enode); } Mencion√© que los High Resolution Timers usan una cola que por debajo es implementada utilizando un Red Black Tree. La llamada a las funciones timerqueue_init solo asigna e inicializa un nodo del Red Black Tree, sin embargo este nodo no es agregado al √°rbol a√∫n.\nDespu√©s de ese breve par√©ntesis, veamos qu√© sucede dentro de la funci√≥n do_nanosleep.\nInicialmente pens√© que el ciclo do/while itera hasta que High Resolution Timer expire (algo como un bucle infinito), sin embargo las cosas suceden de manera diferente.\nstatic int __sched do_nanosleep(struct hrtimer_sleeper *t, enum hrtimer_mode mode) { struct restart_block *restart; do { set_current_state(TASK_INTERRUPTIBLE); // \u003c\u003c\u003c\u003c This causes the process to go to a Sleeping state hrtimer_sleeper_start_expires(t, mode); if (likely(t-\u003etask)) freezable_schedule(); hrtimer_cancel(\u0026t-\u003etimer); mode = HRTIMER_MODE_ABS; } while (t-\u003etask \u0026\u0026 !signal_pending(current)); __set_current_state(TASK_RUNNING); if (!t-\u003etask) return 0; restart = \u0026current-\u003erestart_block; if (restart-\u003enanosleep.type != TT_NONE) { ktime_t rem = hrtimer_expires_remaining(\u0026t-\u003etimer); struct timespec64 rmt; if (rem \u003c= 0) return 0; rmt = ktime_to_timespec64(rem); return nanosleep_copyout(restart, \u0026rmt); } return -ERESTART_RESTARTBLOCK; } Como se mencion√≥ anteriormente, cuando se llama a la funci√≥n sleep, el proceso actual pasar√° al estado Sleeping. Podemos ver que eso sucede en la l√≠nea que llama a la funci√≥n set_current_state que cambia el estado del proceso actual a TASK_INTERRUPTIBLE (Sleeping).\nLa llamada a la funci√≥n hrtimer_sleeper_start_expires llamar√° a otras funciones hasta que llame a __hrtimer_start_range_ns que a su vez llamar√° a enqueue_hrtimer, es en este punto donde el timer (nodo) inicializado antes se agrega a la estructura del Red Black Tree para que el timer pueda ser procesado m√°s tarde.\nFinalmente, la funci√≥n freezable_schedule invoca al process scheduler para que haga schedule de otro proceso, porque el proceso actual current entr√≥ en suspensi√≥n y la ejecuci√≥n de nuestro proceso se detiene aqu√≠.\nC√≥mo Despierta El Proceso? Hasta ahora hemos comprobado que la implementaci√≥n de nanosleep cambia el estado del proceso a TASK_INTERRUPTIBLE y pausa la ejecuci√≥n del proceso.\nAhora que el estado del proceso est√° en el estado TASK_INTERRUPTIBLE, el process scheduler no considerar√° la ejecuci√≥n del proceso hasta que el estado del proceso vuelva a TASK_RUNNING.\nMencionamos que el Hardware Timer causa interrupciones peri√≥dicas para que el Kernel de Linux pueda manejarlas llamando a la funci√≥n hrtimer_interrupt en cada interrupci√≥n (varias veces en un segundo). Es en esta funci√≥n donde se procesan los High Resolution Timers llamando a la funci√≥n __hrtimer_run_queues.\nstatic void __hrtimer_run_queues(struct hrtimer_cpu_base *cpu_base, ktime_t now, unsigned long flags, unsigned int active_mask) { struct hrtimer_clock_base *base; unsigned int active = cpu_base-\u003eactive_bases \u0026 active_mask; for_each_active_base(base, cpu_base, active) { struct timerqueue_node *node; ktime_t basenow; basenow = ktime_add(now, base-\u003eoffset); while ((node = timerqueue_getnext(\u0026base-\u003eactive))) { struct hrtimer *timer; timer = container_of(node, struct hrtimer, node); if (basenow \u003c hrtimer_get_softexpires_tv64(timer)) break; __run_hrtimer(cpu_base, base, timer, \u0026basenow, flags); if (active_mask == HRTIMER_ACTIVE_SOFT) hrtimer_sync_wait_running(cpu_base, flags); } } } La funci√≥n __hrtimer_run_queues iterar√° los timers en el Red Black Tree, recuerden que iterar√° comenzando por los timers que est√°n m√°s pr√≥ximos a expirar. Algo a tener en cuenta aqu√≠ es que romper√° el ciclo while si el timer a√∫n no ha expirado (¬øpor qu√© tener iteraciones innecesarias si el header de la cola es un timer que no ha caducado a√∫n?). Pero cuando el timer expire, llamar√° a la funci√≥n __run_hrtimer. Como podemos ver, su implementaci√≥n llamar√° al callback que configuramos durante la inicializaci√≥n del High Resolution Timer.\nstatic void __run_hrtimer(struct hrtimer_cpu_base *cpu_base, struct hrtimer_clock_base *base, struct hrtimer *timer, ktime_t *now, unsigned long flags) __must_hold(\u0026cpu_base-\u003elock) { ... fn = timer-\u003efunction; // \u003c\u003c\u003c\u003c\u003c This fn function is pointing to the hrtimer_wakeup function ... restart = fn(timer); ... } La funci√≥n que se configur√≥ como el callback durante la inicializaci√≥n del High Resolution Timer fue la funci√≥n hrtimer_wakeup.\nstatic enum hrtimer_restart hrtimer_wakeup(struct hrtimer *timer) { struct hrtimer_sleeper *t = container_of(timer, struct hrtimer_sleeper, timer); struct task_struct *task = t-\u003etask; t-\u003etask = NULL; if (task) wake_up_process(task); // \u003c\u003c\u003c\u003c\u003c\u003c Wake up the process!! return HRTIMER_NORESTART; } Como podemos ver, esta funci√≥n llamar√° a la funci√≥n wake_up_process enviando el proceso (tarea) asociado con el High Resolution Timer como par√°metro. La funci√≥n wake_up_process, entre otras cosas, establecer√° el estado del proceso en TASK_RUNNING.\nAlgunos ciclos de CPU m√°s tarde, el process schduler reanudar√° la ejecuci√≥n de nuestro proceso donde se detuvo (despu√©s de la llamada a la funci√≥n freezable_schedule). Luego, el resto de la funci√≥n do_nanosleep liberar√° memoria, eliminar√° el timer del Red Black Tree y continuar√° con la ejecuci√≥n. ¬°Y eso es todo!\nHay otras alternativas a nanosleep La syscall nanosleep no es la √∫nica syscall que se puede usar para dormir un proceso. Por ejemplo, la funci√≥n time.sleep de Python usa la syscall select por detr√°s, sin embargo, si revisamos la implementaci√≥n de do_select que a su vez llama a la funci√≥n schedule_hrtimeout_range, se nota que llama a la funci√≥n schedule_hrtimeout_range que inicializa un High Resolution Timer y le dice al process scheduler que haga schedule de otro proceso (la misma l√≥gica que con nanosleep).\nPython sleep es un ejemplo, pero otros lenguajes posiblemente usan otras syscalls.\nComentarios Finales Aunque llamar a la funci√≥n sleep en nuestros programas puede ser algo trivial, todos los mecanismos que viven detr√°s de esa simple funci√≥n son asombrosos. Cuando comenc√© a investigar para entender qu√© sucede cuando llamas a una funci√≥n sleep, no me hubiera imaginado cu√°nto iba a aprender.\nEn caso de que haya partes de este post que sean incorrectas, puedenm abrir un issue en el repositorio de Github de este blog. ¬°Muchas gracias!.\nReferencias [0] https://lwn.net/Articles/167897/ [1] https://lwn.net/Articles/152436/ [2] https://www.kernel.org/doc/html/latest/timers/hrtimers.html [3] https://www.kernel.org/doc/html/latest/timers/highres.html [4] https://www.youtube.com/watch?v=Puv4mW55bF8 ",
  "wordCount" : "3081",
  "inLanguage": "es",
  "image": "https://blog.donkeysharp.xyz/images/papermod-cover.png","datePublished": "2022-03-10T00:00:00Z",
  "dateModified": "2022-03-10T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "donkeysharp"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://blog.donkeysharp.xyz/es/post/what-happens-when-a-process-goes-to-sleep/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Donkeysharp",
    "logo": {
      "@type": "ImageObject",
      "url": "https://blog.donkeysharp.xyz/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://blog.donkeysharp.xyz/es/" accesskey="h" title="Donkeysharp (Alt + H)">Donkeysharp</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://blog.donkeysharp.xyz/" title="English"
                            aria-label="English">English</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://blog.donkeysharp.xyz/es/archive" title="Archivo">
                    <span>Archivo</span>
                </a>
            </li>
            <li>
                <a href="https://blog.donkeysharp.xyz/es/about/" title="Sobre m√≠">
                    <span>Sobre m√≠</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://blog.donkeysharp.xyz/es/">Inicio</a>&nbsp;¬ª&nbsp;<a href="https://blog.donkeysharp.xyz/es/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Qu√© sucede cuando un proceso de Linux se va a dormir?
    </h1>
    <div class="post-meta"><span title='2022-03-10 00:00:00 +0000 UTC'>marzo 10, 2022</span>&nbsp;¬∑&nbsp;15 min&nbsp;¬∑&nbsp;donkeysharp&nbsp;|&nbsp;Traducciones:
<ul class="i18n_list">
    <li>
        <a href="https://blog.donkeysharp.xyz/post/what-happens-when-a-process-goes-to-sleep/">English</a>
    </li>
</ul>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Tabla de Contenidos</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#process-state" aria-label="Process State">Process State</a><ul>
                        
                <li>
                    <a href="#tldr-super-resumido" aria-label="TL;DR (super resumido)">TL;DR (super resumido)</a></li></ul>
                </li>
                <li>
                    <a href="#yendo-m%c3%a1s-a-fondo" aria-label="Yendo M√°s A Fondo">Yendo M√°s A Fondo</a><ul>
                        
                <li>
                    <a href="#high-resolution-timers" aria-label="High Resolution Timers">High Resolution Timers</a></li>
                <li>
                    <a href="#hardware-timer" aria-label="Hardware Timer">Hardware Timer</a></li>
                <li>
                    <a href="#implementaci%c3%b3n-de-la-syscall-nanosleep-en-linux" aria-label="Implementaci√≥n de la syscall nanosleep en Linux">Implementaci√≥n de la syscall nanosleep en Linux</a><ul>
                        
                <li>
                    <a href="#c%c3%b3mo-despierta-el-proceso" aria-label="C√≥mo Despierta El Proceso?">C√≥mo Despierta El Proceso?</a></li></ul>
                </li>
                <li>
                    <a href="#hay-otras-alternativas-a-nanosleep" aria-label="Hay otras alternativas a nanosleep">Hay otras alternativas a nanosleep</a></li>
                <li>
                    <a href="#comentarios-finales" aria-label="Comentarios Finales">Comentarios Finales</a></li></ul>
                </li>
                <li>
                    <a href="#referencias" aria-label="Referencias">Referencias</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Es posible que cuando estas escribiendo un programa, en alg√∫n momento necesites pausar la ejecuci√≥n de un proceso llamando a la funci√≥n <code>sleep(NUMBER_OF_SECONDS)</code> dependiendo del problema que est√©s resolviendo. En este post, compartir√© lo que aprend√≠ hasta ahora mientras investigaba los mecanismos internos del kernel que hacen que la funci√≥n <code>sleep</code> funcione de la forma en que lo hace.</p>
<blockquote>
<p><strong>Agradezco su feedback.</strong> No soy un experto en este tema ya que las partes internas del Kernel de Linux son nuevas para m√≠, fue solo mi curiosidad lo que me llev√≥ a revisar el c√≥digo fuente del Kernel y quer√≠a compartir lo que aprend√≠. Si encuentran algo incorrecto en este post, pueden abrir un issue en el <a href="https://github.com/donkeysharp/donkeysharp.github.io">repositorio de Github</a> de este blog. Gracias!.</p></blockquote>
<h2 id="process-state">Process State<a hidden class="anchor" aria-hidden="true" href="#process-state">#</a></h2>
<p>Uno de los primeros conceptos que necesitamos revisar es el estado de un proceso. Un proceso en Linux tiene un estado asociado que representa su estado de ejecuci√≥n en el sistema operativo. Un proceso puede estar en uno de los siguientes estados:</p>
<ul>
<li>Running</li>
<li>Sleeping (interruptible and uninterruptible)</li>
<li>Stopped</li>
<li>Zombie</li>
</ul>
<p>Cuando un proceso est√° ejecutando instrucciones en la CPU, se encuentra en estado &ldquo;Running&rdquo; y cuando el proceso est√° esperando que suceda algo, es decir, esperando I/O de red o disco, o se llama a la funcion <code>sleep</code>, cambiar√° a un estado <code>Sleeping</code>.</p>
<p>Podemos comprobarlo con un sencillo programa de ejemplo en C:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// states.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// gcc states.c -o states
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define SOME_MAGIC_NUMBER 365000000l
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">start_processing</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> i;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Starting Loop</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> (<span style="color:#66d9ef">long</span>)(<span style="color:#ae81ff">10</span> <span style="color:#f92672">*</span> SOME_MAGIC_NUMBER); i<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Loop Finished</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">pid_t</span> pid <span style="color:#f92672">=</span> <span style="color:#a6e22e">getpid</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;PID: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, pid);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">start_processing</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Sleep process</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">sleep</span>(<span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Sleep finished</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">start_processing</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>El c√≥digo anterior ejecutar√° un loop durante algunos segundos, luego se suspender√° durante 5 segundos y finalmente ejecutar√° otro loop durante otro n√∫mero de segundos. Por lo tanto, esperamos que el estado del proceso sea <code>Running -&gt; Sleeping -&gt; Running</code>.</p>
<p>Mientras se ejecuta el programa, podemos comprobar el estado del proceso con la herramienta <a href="https://htop.dev/">Htop</a>, que normalmente mostrar√° una letra en la octava columna que representa el estado del proceso, e.g. <code>R</code> (Running), <code>S</code> (Sleeping), <code>T</code> (Stopped), etc.</p>
<p><img loading="lazy" src="/img/sleep-post/process-state.gif"></p>
<p>Como era de esperar, los estados que ten√≠a el proceso durante la ejecuci√≥n fueron: <code>Running (R) -&gt; Sleeping (S) -&gt; Running (R)</code>.</p>
<h3 id="tldr-super-resumido">TL;DR (super resumido)<a hidden class="anchor" aria-hidden="true" href="#tldr-super-resumido">#</a></h3>
<p>Cuando un programa llama a la funci√≥n <code>sleep(NUMBER_OF_SECONDS)</code> (en C), este usar√° la llamada al sistema (syscall) <code>nanosleep</code>. Otros lenguajes de programaci√≥n usan diferentes syscalls que tambi√©n pueden enviar un proceso a dormir durante algunos segundos, e.g. <code>select</code>.</p>
<p>La implementaci√≥n del kernel de Linux de la syscall <code>nanosleep</code> har√° lo siguiente:</p>
<ul>
<li>Inicializar un High Resolution sleep timer.</li>
<li>Cambiar el estado del proceso a <code>TASK_INTERRUPTIBLE (Sleeping)</code>.</li>
<li>Inicia el High Resolution sleep timer.</li>
<li>Indicar al scheduler de procesos para poner a otro proceso en ejecuci√≥n y pausar la ejecuci√≥n del proceso actual.</li>
</ul>
<p>El kernel de Linux procesa los High Resolution Timers de la siguiente manera:</p>
<ul>
<li>El hardware de la computadora tiene un CPU timer que causa interrupciones peri√≥dicamente, haciendo que el kernel las maneje llamando a la funci√≥n <code>hrtimer_interrupt</code>.</li>
<li>La funci√≥n <code>hrtimer_interrupt</code> procesar√° los High Resolution Timers (a nivel de software) existentes y ver√° si un timer expir√≥. Una vez que un High Resolution Timer expire, el kernel llamar√° a la funci√≥n <code>hrtimer_wakeup</code> que activar√° el proceso asociado con el timer, y eso cambiar√° el estado de <code>TASK_INTERRUPTIBLE (Sleeping)</code> a <code>TASK_RUNNING (Running)</code>.</li>
<li>Finalmente, algunos ciclos de CPU m√°s tarde, el scheduler de procesos continuar√° la ejecuci√≥n del proceso exactamente donde se detuvo.</li>
</ul>
<p>Sigue leyendo si est√° interesado en m√°s detalles.</p>
<h2 id="yendo-m√°s-a-fondo">Yendo M√°s A Fondo<a hidden class="anchor" aria-hidden="true" href="#yendo-m√°s-a-fondo">#</a></h2>
<p>Como ingenieros de software, es probable que la mayor parte del tiempo estemos escribiendo aplicaciones que se ejecutan en <a href="https://en.wikipedia.org/wiki/User_space">user space o user mode</a>, como servidores (de cualquier tipo) o aplicaciones del lado del servidor, web , aplicaciones m√≥viles o de escritorio, scripts de automatizaci√≥n, etc.</p>
<p>No importa el lenguaje de programaci√≥n, el framework o la tecnolog√≠a, internamente un programa que se ejecuta en user mode siempre interactuar√° de una forma u otra con el sistema operativo (en este post Linux) a trav√©s de <a href="https://en.wikipedia.org/wiki/System_call">System Calls o syscalls</a>. Por ejemplo, cuando leemos un archivo, nuestro c√≥digo (sin importar el lenguaje de programaci√≥n) se comunicar√° indirectamente con el Kernel de Linux a trav√©s de la syscall <code>read</code> (no es la √∫nica), luego el kernel le pedir√° al disco duro f√≠sico el contenido del archivo que queremos basado en el sistema de archivos, y finalmente devolver√° el contenido solicitado a nuestro programa.</p>
<p>Hay una herramienta llamada <a href="https://man7.org/linux/man-pages/man1/strace.1.html">Strace</a> que monitorea todas las syscall que ejecuta un proceso.</p>
<p>Si ejecutamos el ejemplo anterior en C usando <code>strace</code>, podemos ver la siguiente salida:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ strace ./states
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>... syscalls <span style="color:#66d9ef">for</span> process loading <span style="color:#f92672">(</span>they won<span style="color:#960050;background-color:#1e0010">&#39;</span>t be useful right now<span style="color:#f92672">)</span> ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>write<span style="color:#f92672">(</span>1, <span style="color:#e6db74">&#34;PID: 26846\n&#34;</span>, 11PID: <span style="color:#ae81ff">26846</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">)</span>            <span style="color:#f92672">=</span> <span style="color:#ae81ff">11</span>
</span></span><span style="display:flex;"><span>write<span style="color:#f92672">(</span>1, <span style="color:#e6db74">&#34;Starting Loop\n&#34;</span>, 14Starting Loop
</span></span><span style="display:flex;"><span><span style="color:#f92672">)</span>         <span style="color:#f92672">=</span> <span style="color:#ae81ff">14</span>
</span></span><span style="display:flex;"><span>write<span style="color:#f92672">(</span>1, <span style="color:#e6db74">&#34;Loop Finished\n&#34;</span>, 14Loop Finished
</span></span><span style="display:flex;"><span><span style="color:#f92672">)</span>         <span style="color:#f92672">=</span> <span style="color:#ae81ff">14</span>
</span></span><span style="display:flex;"><span>write<span style="color:#f92672">(</span>1, <span style="color:#e6db74">&#34;Sleep process\n&#34;</span>, 14Sleep process
</span></span><span style="display:flex;"><span><span style="color:#f92672">)</span>         <span style="color:#f92672">=</span> <span style="color:#ae81ff">14</span>
</span></span><span style="display:flex;"><span>nanosleep<span style="color:#f92672">({</span>tv_sec<span style="color:#f92672">=</span>5, tv_nsec<span style="color:#f92672">=</span>0<span style="color:#f92672">}</span>, 0x7ffefc933be0<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>write<span style="color:#f92672">(</span>1, <span style="color:#e6db74">&#34;Sleep finished\n&#34;</span>, 15Sleep finished
</span></span><span style="display:flex;"><span><span style="color:#f92672">)</span>        <span style="color:#f92672">=</span> <span style="color:#ae81ff">15</span>
</span></span><span style="display:flex;"><span>write<span style="color:#f92672">(</span>1, <span style="color:#e6db74">&#34;Starting Loop\n&#34;</span>, 14Starting Loop
</span></span><span style="display:flex;"><span><span style="color:#f92672">)</span>         <span style="color:#f92672">=</span> <span style="color:#ae81ff">14</span>
</span></span><span style="display:flex;"><span>write<span style="color:#f92672">(</span>1, <span style="color:#e6db74">&#34;Loop Finished\n&#34;</span>, 14Loop Finished
</span></span><span style="display:flex;"><span><span style="color:#f92672">)</span>         <span style="color:#f92672">=</span> <span style="color:#ae81ff">14</span>
</span></span><span style="display:flex;"><span>exit_group<span style="color:#f92672">(</span>0<span style="color:#f92672">)</span>                           <span style="color:#f92672">=</span> ?
</span></span><span style="display:flex;"><span>+++ exited with <span style="color:#ae81ff">0</span> +++
</span></span></code></pre></div><p>La salida verdadera es m√°s larga que la que se muestra arriba, pero la mayor√≠a de las primeras syscalls siempre se ejecutan cuando se inicia un proceso y carga la biblioteca est√°ndar de C entre otras cosas, pero las que nos interesa revisar son las √∫ltimas.</p>
<p>La syscall <code>write</code> le dice al Kernel que el programa quiere mostrar una cadena de texto en la <a href="https://en.wikipedia.org/wiki/Standard_streams#Standard_output_%28stdout%29">salida est√°ndar</a> (en este caso la terminal). Con esa informaci√≥n, podemos tener una idea de que la funci√≥n <code>printf</code> se comunica con el sistema operativo llamando a la syscall <code>write</code>.</p>
<p>Luego se llama a la syscall <code>nanosleep</code>, que indicar√° al kernel de Linux que mueva el proceso de un estado Running a un estado Sleeping.</p>
<p>Antes de revisar la implementaci√≥n en Linux de la syscall <code>nanosleep</code>, primero tenemos que revisar un par de conceptos para tener una mejor comprensi√≥n de lo que viene.</p>
<h3 id="high-resolution-timers">High Resolution Timers<a hidden class="anchor" aria-hidden="true" href="#high-resolution-timers">#</a></h3>
<p>Dentro del kernel de Linux, diferentes componentes deben esperar un tiempo antes de ejecutar algo, aqu√≠ es donde entra el concepto de Timers. Un timer es una estructura (struct) en la que definimos su tiempo de expiraci√≥n (el tiempo de espera) y qu√© funci√≥n se llamar√° una vez que el timer expira.</p>
<p>El kernel de Linux tiene dos tipos de timers: Low Resolution Timers y High Resolution Timers. Revisaremos los Hight Resolution Timers.</p>
<p>El framework detr√°s de los High Resolution Timers dentro del kernel de Linux es un conjunto de structs y funciones que procesan los timers de manera √≥ptima. Su implementaci√≥n se basa en una cola de timers que se ordenan por el timer que expirar√° m√°s pronto. Para que esta cola sea eficiente, utiliza la estructura de datos <a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">Red Black Tree</a> para que la inserci√≥n y la eliminaci√≥n se puedan realizar en tiempo logar√≠tmico.</p>
<p>Este framework es muy interesante como tal, en este art√≠culo solo revisaremos c√≥mo se usa y algunas partes espec√≠ficas de su implementaci√≥n. Para obtener m√°s informaci√≥n sobre los detalles de implementaci√≥n, lea <a href="/es/post/what-happens-when-a-process-goes-to-sleep/#references">[0]</a>, <a href="/es/post/what-happens-when-a-process-goes-to-sleep/#references">[1]</a> y <a href="/es/post/what-happens-when-a-process-goes-to-sleep/#references">[2]</a>.</p>
<blockquote>
<p>La gesti√≥n del tiempo o time management dentro del kernel de Linux es un tema muy interesante y la charla dada por <a href="https://www.linkedin.com/in/stephen-w-boyd/">Stephen Boyd</a> titulada <strong>&ldquo;Timekeeping In The Linux Kernel&rdquo;</strong> <a href="/es/post/what-happens-when-a-process-goes-to-sleep/#references">[4]</a> me dio una mejor comprensi√≥n de c√≥mo el Kernel de Linux maneja las tareas relacionadas al tiempo, as√≠ como su complejidad. Esta charla me ayud√≥ mucho. ¬°Gracias!</p></blockquote>
<h3 id="hardware-timer">Hardware Timer<a hidden class="anchor" aria-hidden="true" href="#hardware-timer">#</a></h3>
<p>La CPU (f√≠sicamente) tiene un reloj e internamente tiene un timer programable. En palabras simples, el objetivo principal de este timer es causar <a href="https://en.wikipedia.org/wiki/Interrupt#Hardware_interrupts">interrupciones</a> peri√≥dicamente (muchas veces dentro de un segundo) para que el kernel pueda manejarlas. La frecuencia de estas interrupciones depender√° de la arquitectura que se especifique en el Kernel de Linux durante su compilaci√≥n. El kernel de Linux abstrae esto como <a href="https://www.kernel.org/doc/html/latest/timers/timekeeping.html#clock-events">Clock Event Devices</a> y hay un Clock Event Device por CPU. Se utiliza un Clock Event Device para programar la siguiente interrupci√≥n que se generar√° <a href="/es/post/what-happens-when-a-process-goes-to-sleep/#references">[3]</a>.</p>
<p>Cuando ocurre una interrupci√≥n del timer, el kernel de Linux lo manejar√° llamando a una funci√≥n. <a href="/es/post/what-happens-when-a-process-goes-to-sleep/#references">[4]</a> menciona que para los High Resolution Timers, la funci√≥n <code>hrtimer_interrupt</code> es el manejador de las interrupciones del timer (revisaremos su c√≥digo m√°s adelante).</p>
<p>Otra forma de verificar qu√© manejador se utilizar√°, es revisar el archivo de solo lectura <code>/proc/timer_list</code> que contiene la lista de timers pendientes y los Clock Event devices.</p>
<p>En mi caso, valid√© que el manejador de estos dispositivos en mi m√°quina es efectivamente la funci√≥n <code>hrtimer_interrup</code>.</p>
<pre tabindex="0"><code># /proc/timer_list
....

Tick Device: mode:     1
Per CPU device: 0
Clock Event Device: lapic-deadline
 max_delta_ns:   1916620707137
 min_delta_ns:   1000
 mult:           9624619
 shift:          25
 mode:           3
 next_event:     14403083615478 nsecs
 set_next_event: lapic_next_deadline
 shutdown: lapic_timer_shutdown
 periodic: lapic_timer_set_periodic
 oneshot:  lapic_timer_set_oneshot
 oneshot stopped: lapic_timer_shutdown
 event_handler:  hrtimer_interrupt              &lt;&lt;&lt;&lt;&lt;&lt;&lt; the interrupt handler
 retries:        1316

Tick Device: mode:     1
Per CPU device: 1
Clock Event Device: lapic-deadline
 max_delta_ns:   1916620707137
 min_delta_ns:   1000
 mult:           9624619
 shift:          25
 mode:           3
 next_event:     14403083615478 nsecs
 set_next_event: lapic_next_deadline
 shutdown: lapic_timer_shutdown
 periodic: lapic_timer_set_periodic
 oneshot:  lapic_timer_set_oneshot
 oneshot stopped: lapic_timer_shutdown
 event_handler:  hrtimer_interrupt              &lt;&lt;&lt;&lt;&lt;&lt;&lt; the interrupt handler
 retries:        484
.... The rest of devices per CPU of my machine
</code></pre><p>Ahora que tenemos una idea de los High Resolution Timers y que la CPU tiene un timer de hardware que peri√≥dicamente causa interrupciones al kernel, podemos continuar con la syscall <code>nanosleep</code>.</p>
<h3 id="implementaci√≥n-de-la-syscall-nanosleep-en-linux">Implementaci√≥n de la syscall <code>nanosleep</code> en Linux<a hidden class="anchor" aria-hidden="true" href="#implementaci√≥n-de-la-syscall-nanosleep-en-linux">#</a></h3>
<blockquote>
<p>El Kernel de Linux es un proyecto enorme, miles de archivos y millones de l√≠neas de c√≥digo, navegar a trav√©s de ellos puede ser todo un desaf√≠o. Hay una herramienta online llamada LXR que ayuda a navegar el c√≥digo fuente del Kernel de Linux de manera amigable. La URL del sitio es <a href="https://elixir.bootlin.com/linux">https://elixir.bootlin.com/linux/5.14/source</a>.</p></blockquote>
<p>Hasta ahora sabemos que la syscall <code>nanosleep</code> hace toda la magia para mover el estado del proceso de Running a Sleeping durante un determinado n√∫mero de segundos, luego pasar al estado Running nuevamente. Ahora exploraremos el c√≥digo fuente del kernel de Linux y revisaremos cu√°les son los mecanismos internos detr√°s de ese comportamiento &ldquo;simple&rdquo;.</p>
<p>Primero, tenemos que verificar d√≥nde est√° definida la syscall <code>nanosleep</code>. Despu√©s de buscar un poco en Google, encontr√© un documento que especifica c√≥mo <a href="https://www.kernel.org/doc/html/latest/process/adding-syscalls.html#generic-system-call-implementation">se definen las syscall</a> en el kernel de Linux. Por lo tanto, tenemos que buscar <code>SYSCALL_DEFINE2(nanosleep, ....)</code>, el <code>2</code> en <code>SYSCALL_DEFINE2</code> indica el n√∫mero de argumentos de la syscall. S√© que <code>nanosleep</code> tiene dos argumentos despu√©s de comprobar en su <a href="https://man7.org/linux/man-pages/man2/nanosleep.2.html">manual</a> (todas las syscall tienen una p√°gina man(2)).</p>
<p>Despu√©s de buscar el t√©rmino <code>nanosleep</code> en LXR, encontr√© que la syscall est√° definida en archivo <a href="https://elixir.bootlin.com/linux/5.14/source/kernel/time/hrtimer.c#L1970">kernel/time/hrtimer.c</a> .</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">SYSCALL_DEFINE2</span>(nanosleep, <span style="color:#66d9ef">struct</span> __kernel_timespec __user <span style="color:#f92672">*</span>, rqtp,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> __kernel_timespec __user <span style="color:#f92672">*</span>, rmtp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> timespec64 tu;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">get_timespec64</span>(<span style="color:#f92672">&amp;</span>tu, rqtp))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EFAULT;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">timespec64_valid</span>(<span style="color:#f92672">&amp;</span>tu))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  current<span style="color:#f92672">-&gt;</span>restart_block.nanosleep.type <span style="color:#f92672">=</span> rmtp <span style="color:#f92672">?</span> TT_NATIVE : TT_NONE;
</span></span><span style="display:flex;"><span>  current<span style="color:#f92672">-&gt;</span>restart_block.nanosleep.rmtp <span style="color:#f92672">=</span> rmtp;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">hrtimer_nanosleep</span>(<span style="color:#a6e22e">timespec64_to_ktime</span>(tu), HRTIMER_MODE_REL,
</span></span><span style="display:flex;"><span>         CLOCK_MONOTONIC);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Por supuesto, cada l√≠nea de c√≥digo tiene su raz√≥n de ser, pero resaltar√© la llamada a <code>timespec64_to_ktime</code> que convierte los argumentos de entrada de la syscall en la estructura <code>ktime</code> que es utilizada por el framework de High Resolution Timers. Finalmente, llama a la funci√≥n <code>hrtimer_nanosleep</code> donde comienza toda la diversi√≥n.</p>
<p>Ir√© funci√≥n por funci√≥n en el orden en que son llamadas y explicar√© las partes que considero relevantes:</p>
<p>La funci√≥n <a href="https://elixir.bootlin.com/linux/5.14/source/kernel/time/hrtimer.c#L1935">hrtimer_nanosleep</a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">hrtimer_nanosleep</span>(<span style="color:#66d9ef">ktime_t</span> rqtp, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">enum</span> hrtimer_mode mode, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">clockid_t</span> clockid)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">hrtimer_init_sleeper_on_stack</span>(<span style="color:#f92672">&amp;</span>t, clockid, mode);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">hrtimer_set_expires_range_ns</span>(<span style="color:#f92672">&amp;</span>t.timer, rqtp, slack);
</span></span><span style="display:flex;"><span>  ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">do_nanosleep</span>(<span style="color:#f92672">&amp;</span>t, mode);
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Hay tres partes relevantes aqu√≠:</p>
<ul>
<li>La inicializaci√≥n del High Resolution Timer (lo revisaremos m√°s adelante)</li>
<li>El tiempo de expiraci√≥n del timer inicializado. Aunque parece una tarea simple, hay mucha l√≥gica por debajo. Debido a que el Kernel de Linux funciona a nivel de hardware, para convertir el tiempo humano en tiempo de computadora tiene que usar algunas f√≥rmulas que se basan en la constante HZ que var√≠a seg√∫n la arquitectura. Adem√°s, aparece el concepto de <a href="https://en.wikipedia.org/wiki/Jiffy_%28time%29">Jiffies</a>. No entrar√© en m√°s detalles, sin embargo <a href="/es/post/what-happens-when-a-process-goes-to-sleep/#references">[4]</a> explica muy bien esta parte.</li>
<li>Finalmente, llama a la funci√≥n <code>do_nanosleep</code> que tiene la l√≥gica que env√≠a un proceso a dormir.</li>
</ul>
<p>La funci√≥n <a href="https://elixir.bootlin.com/linux/5.14/source/kernel/time/hrtimer.c#L442">hrtimer_init_sleeper_on_stack</a> (que al final llama a <a href="https://elixir.bootlin.com/linux/5.14/source/kernel/time/hrtimer.c#L1821">__hrtimer_init_sleeper</a>) asigna e inicializa un High Resolution Timer asociado con el proceso actual que se est√° ejecutando.</p>
<p>El atributo <code>function</code> del High Resolution Sleep Timer es la funci√≥n callback, lo que significa que este atributo <code>function</code> se llamar√° despu√©s de que expire el High Resolution Timer. En este caso el valor del <a href="https://elixir.bootlin.com/linux/v5.14/source/kernel/time/hrtimer.c#L1849">atributo function</a> es la funci√≥n <code>hrtimer_wakeup</code> que veremos m√°s adelante (no se olviden de esto &#x1f609;).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__hrtimer_init_sleeper</span>(<span style="color:#66d9ef">struct</span> hrtimer_sleeper <span style="color:#f92672">*</span>sl,
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">clockid_t</span> clock_id, <span style="color:#66d9ef">enum</span> hrtimer_mode mode)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">__hrtimer_init</span>(<span style="color:#f92672">&amp;</span>scicil<span style="color:#f92672">-&gt;</span>timer, clock_id, mode);
</span></span><span style="display:flex;"><span>  sl<span style="color:#f92672">-&gt;</span>timer.function <span style="color:#f92672">=</span> hrtimer_wakeup; <span style="color:#75715e">// &lt;&lt;&lt;&lt;&lt;&lt; This function will be called after the timer expires
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  sl<span style="color:#f92672">-&gt;</span>task <span style="color:#f92672">=</span> current;                  <span style="color:#75715e">// &lt;&lt;&lt;&lt;&lt;&lt; Associates the timer with the current process
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><blockquote>
<p>En el kernel de Linux, la variable <code>current</code> es un puntero al proceso actual que se est√° ejecutando (en nuestro caso, el programa que llama a la funci√≥n <code>sleep</code>).</p></blockquote>
<p>Antes de continuar con la funci√≥n <code>do_nanosleep</code>, har√© un par√©ntesis sobre la funci√≥n <a href="https://elixir.bootlin.com/linux/5.14/source/kernel/time/hrtimer.c#L1393">__hrtimer_init</a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__hrtimer_init</span>(<span style="color:#66d9ef">struct</span> hrtimer <span style="color:#f92672">*</span>timer, <span style="color:#66d9ef">clockid_t</span> clock_id,
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">enum</span> hrtimer_mode mode)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">timerqueue_init</span>(<span style="color:#f92672">&amp;</span>timer<span style="color:#f92672">-&gt;</span>node);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Mencion√© que los High Resolution Timers usan una cola que por debajo es implementada utilizando un Red Black Tree. La llamada a las funciones <a href="https://elixir.bootlin.com/linux/5.14/source/include/linux/timerqueue.h#L43">timerqueue_init</a> solo asigna e inicializa un nodo del Red Black Tree, sin embargo este nodo no es agregado al √°rbol a√∫n.</p>
<p>Despu√©s de ese breve par√©ntesis, veamos qu√© sucede dentro de la funci√≥n <a href="https://elixir.bootlin.com/linux/5.14/source/kernel/time/hrtimer.c#L1887">do_nanosleep</a>.</p>
<p>Inicialmente pens√© que el ciclo do/while itera hasta que High Resolution Timer expire (algo como un bucle infinito), sin embargo las cosas suceden de manera diferente.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> __sched <span style="color:#a6e22e">do_nanosleep</span>(<span style="color:#66d9ef">struct</span> hrtimer_sleeper <span style="color:#f92672">*</span>t, <span style="color:#66d9ef">enum</span> hrtimer_mode mode)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> restart_block <span style="color:#f92672">*</span>restart;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">set_current_state</span>(TASK_INTERRUPTIBLE);   <span style="color:#75715e">// &lt;&lt;&lt;&lt; This causes the process to go to a Sleeping state
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">hrtimer_sleeper_start_expires</span>(t, mode);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">likely</span>(t<span style="color:#f92672">-&gt;</span>task))
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">freezable_schedule</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">hrtimer_cancel</span>(<span style="color:#f92672">&amp;</span>t<span style="color:#f92672">-&gt;</span>timer);
</span></span><span style="display:flex;"><span>    mode <span style="color:#f92672">=</span> HRTIMER_MODE_ABS;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">while</span> (t<span style="color:#f92672">-&gt;</span>task <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">signal_pending</span>(current));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">__set_current_state</span>(TASK_RUNNING);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>t<span style="color:#f92672">-&gt;</span>task)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  restart <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>current<span style="color:#f92672">-&gt;</span>restart_block;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (restart<span style="color:#f92672">-&gt;</span>nanosleep.type <span style="color:#f92672">!=</span> TT_NONE) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ktime_t</span> rem <span style="color:#f92672">=</span> <span style="color:#a6e22e">hrtimer_expires_remaining</span>(<span style="color:#f92672">&amp;</span>t<span style="color:#f92672">-&gt;</span>timer);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> timespec64 rmt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (rem <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    rmt <span style="color:#f92672">=</span> <span style="color:#a6e22e">ktime_to_timespec64</span>(rem);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">nanosleep_copyout</span>(restart, <span style="color:#f92672">&amp;</span>rmt);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ERESTART_RESTARTBLOCK;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Como se mencion√≥ anteriormente, cuando se llama a la funci√≥n <code>sleep</code>, el proceso actual pasar√° al estado <code>Sleeping</code>. Podemos ver que eso sucede en la l√≠nea que llama a la funci√≥n <code>set_current_state</code> que cambia el estado del proceso actual a <code>TASK_INTERRUPTIBLE</code> (Sleeping).</p>
<p>La llamada a la funci√≥n <a href="https://elixir.bootlin.com/linux/5.14/source/kernel/time/hrtimer.c#L1804">hrtimer_sleeper_start_expires</a> llamar√° a otras funciones hasta que llame a <a href="https://elixir.bootlin.com/linux/5.14/source/kernel/time/hrtimer.c#L1101">__hrtimer_start_range_ns</a> que a su vez llamar√° a <code>enqueue_hrtimer</code>, es en este punto donde el timer (nodo) inicializado antes se agrega a la estructura del Red Black Tree para que el timer pueda ser procesado m√°s tarde.</p>
<p>Finalmente, la funci√≥n <code>freezable_schedule</code> invoca al process scheduler para que haga schedule de otro proceso, porque el proceso actual <code>current</code> entr√≥ en suspensi√≥n y la ejecuci√≥n de nuestro proceso se detiene aqu√≠.</p>
<h4 id="c√≥mo-despierta-el-proceso">C√≥mo Despierta El Proceso?<a hidden class="anchor" aria-hidden="true" href="#c√≥mo-despierta-el-proceso">#</a></h4>
<p>Hasta ahora hemos comprobado que la implementaci√≥n de <code>nanosleep</code> cambia el estado del proceso a <code>TASK_INTERRUPTIBLE</code> y pausa la ejecuci√≥n del proceso.</p>
<p>Ahora que el estado del proceso est√° en el estado <code>TASK_INTERRUPTIBLE</code>, el process scheduler no considerar√° la ejecuci√≥n del proceso hasta que el estado del proceso vuelva a <code>TASK_RUNNING</code>.</p>
<p>Mencionamos que el <a href="/es/post/what-happens-when-a-process-goes-to-sleep/#hardware-timer">Hardware Timer</a> causa interrupciones peri√≥dicas para que el Kernel de Linux pueda manejarlas llamando a la funci√≥n <a href="https://elixir.bootlin.com/linux/5.14/source/kernel/time/hrtimer.c#L1633">hrtimer_interrupt</a> en cada interrupci√≥n (varias veces en un segundo). Es en esta funci√≥n donde se procesan los High Resolution Timers llamando a la funci√≥n <a href="https://elixir.bootlin.com/linux/5.14/source/kernel/time/hrtimer.c#L1569">__hrtimer_run_queues</a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__hrtimer_run_queues</span>(<span style="color:#66d9ef">struct</span> hrtimer_cpu_base <span style="color:#f92672">*</span>cpu_base, <span style="color:#66d9ef">ktime_t</span> now,
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> active_mask)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> hrtimer_clock_base <span style="color:#f92672">*</span>base;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> active <span style="color:#f92672">=</span> cpu_base<span style="color:#f92672">-&gt;</span>active_bases <span style="color:#f92672">&amp;</span> active_mask;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">for_each_active_base</span>(base, cpu_base, active) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> timerqueue_node <span style="color:#f92672">*</span>node;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ktime_t</span> basenow;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    basenow <span style="color:#f92672">=</span> <span style="color:#a6e22e">ktime_add</span>(now, base<span style="color:#f92672">-&gt;</span>offset);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> ((node <span style="color:#f92672">=</span> <span style="color:#a6e22e">timerqueue_getnext</span>(<span style="color:#f92672">&amp;</span>base<span style="color:#f92672">-&gt;</span>active))) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">struct</span> hrtimer <span style="color:#f92672">*</span>timer;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      timer <span style="color:#f92672">=</span> <span style="color:#a6e22e">container_of</span>(node, <span style="color:#66d9ef">struct</span> hrtimer, node);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (basenow <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">hrtimer_get_softexpires_tv64</span>(timer))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">__run_hrtimer</span>(cpu_base, base, timer, <span style="color:#f92672">&amp;</span>basenow, flags);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (active_mask <span style="color:#f92672">==</span> HRTIMER_ACTIVE_SOFT)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">hrtimer_sync_wait_running</span>(cpu_base, flags);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>La funci√≥n <code>__hrtimer_run_queues</code> iterar√° los timers en el Red Black Tree, recuerden que iterar√° comenzando por los timers que est√°n m√°s pr√≥ximos a expirar. Algo a tener en cuenta aqu√≠ es que romper√° el ciclo while si el timer a√∫n no ha expirado (¬øpor qu√© tener iteraciones innecesarias si el header de la cola es un timer que no ha caducado a√∫n?). Pero cuando el timer expire, llamar√° a la funci√≥n <a href="https://elixir.bootlin.com/linux/5.14/source/kernel/time/hrtimer.c#L1494">__run_hrtimer</a>. Como podemos ver, su implementaci√≥n llamar√° al callback que configuramos durante la inicializaci√≥n del High Resolution Timer.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__run_hrtimer</span>(<span style="color:#66d9ef">struct</span> hrtimer_cpu_base <span style="color:#f92672">*</span>cpu_base,
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> hrtimer_clock_base <span style="color:#f92672">*</span>base,
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> hrtimer <span style="color:#f92672">*</span>timer, <span style="color:#66d9ef">ktime_t</span> <span style="color:#f92672">*</span>now,
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags) <span style="color:#a6e22e">__must_hold</span>(<span style="color:#f92672">&amp;</span>cpu_base<span style="color:#f92672">-&gt;</span>lock)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>  fn <span style="color:#f92672">=</span> timer<span style="color:#f92672">-&gt;</span>function; <span style="color:#75715e">// &lt;&lt;&lt;&lt;&lt; This fn function is pointing to the hrtimer_wakeup function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  ...
</span></span><span style="display:flex;"><span>  restart <span style="color:#f92672">=</span> <span style="color:#a6e22e">fn</span>(timer);
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>La funci√≥n que se configur√≥ como el callback durante la inicializaci√≥n del High Resolution Timer fue la funci√≥n <a href="https://elixir.bootlin.com/linux/5.14/source/kernel/time/hrtimer.c#L1783">hrtimer_wakeup</a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">enum</span> hrtimer_restart <span style="color:#a6e22e">hrtimer_wakeup</span>(<span style="color:#66d9ef">struct</span> hrtimer <span style="color:#f92672">*</span>timer)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> hrtimer_sleeper <span style="color:#f92672">*</span>t <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">container_of</span>(timer, <span style="color:#66d9ef">struct</span> hrtimer_sleeper, timer);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>task <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>task;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  t<span style="color:#f92672">-&gt;</span>task <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (task)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">wake_up_process</span>(task);    <span style="color:#75715e">// &lt;&lt;&lt;&lt;&lt;&lt; Wake up the process!!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> HRTIMER_NORESTART;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Como podemos ver, esta funci√≥n llamar√° a la funci√≥n <code>wake_up_process</code> enviando el proceso (tarea) asociado con el High Resolution Timer como par√°metro. La funci√≥n <code>wake_up_process</code>, entre otras cosas, establecer√° el estado del proceso en <code>TASK_RUNNING</code>.</p>
<p>Algunos ciclos de CPU m√°s tarde, el process schduler reanudar√° la ejecuci√≥n de nuestro proceso donde se detuvo (despu√©s de la llamada a la funci√≥n <code>freezable_schedule</code>). Luego, el resto de la funci√≥n <code>do_nanosleep</code> liberar√° memoria, eliminar√° el timer del Red Black Tree y continuar√° con la ejecuci√≥n. ¬°Y eso es todo!</p>
<h3 id="hay-otras-alternativas-a-nanosleep">Hay otras alternativas a <code>nanosleep</code><a hidden class="anchor" aria-hidden="true" href="#hay-otras-alternativas-a-nanosleep">#</a></h3>
<p>La syscall <code>nanosleep</code> no es la √∫nica syscall que se puede usar para dormir un proceso. Por ejemplo, la funci√≥n <code>time.sleep</code> de Python usa la syscall <code>select</code> por detr√°s, sin embargo, si revisamos la implementaci√≥n de <a href="https://elixir.bootlin.com/linux/5.14/source/fs/select.c#L476">do_select</a> que a su vez llama a la funci√≥n <a href="https://elixir.bootlin.com/linux/5.14/source/fs/select.c#L236">schedule_hrtimeout_range</a>, se nota que llama a la funci√≥n <code>schedule_hrtimeout_range</code> que inicializa un High Resolution Timer y le dice al process scheduler que haga schedule de otro proceso (la misma l√≥gica que con <code>nanosleep</code>).</p>
<p>Python <code>sleep</code> es un ejemplo, pero otros lenguajes posiblemente usan otras syscalls.</p>
<h3 id="comentarios-finales">Comentarios Finales<a hidden class="anchor" aria-hidden="true" href="#comentarios-finales">#</a></h3>
<p>Aunque llamar a la funci√≥n <code>sleep</code> en nuestros programas puede ser algo trivial, todos los mecanismos que viven detr√°s de esa simple funci√≥n son asombrosos. Cuando comenc√© a investigar para entender qu√© sucede cuando llamas a una funci√≥n <code>sleep</code>, no me hubiera imaginado cu√°nto iba a aprender.</p>
<p>En caso de que haya partes de este post que sean incorrectas, puedenm abrir un issue en el <a href="https://github.com/donkeysharp/donkeysharp.github.io">repositorio de Github</a> de este blog. ¬°Muchas gracias!.</p>
<h2 id="referencias">Referencias<a hidden class="anchor" aria-hidden="true" href="#referencias">#</a></h2>
<ul>
<li>[0] <a href="https://lwn.net/Articles/167897/">https://lwn.net/Articles/167897/</a></li>
<li>[1] <a href="https://lwn.net/Articles/152436/">https://lwn.net/Articles/152436/</a></li>
<li>[2] <a href="https://www.kernel.org/doc/html/latest/timers/hrtimers.html">https://www.kernel.org/doc/html/latest/timers/hrtimers.html</a></li>
<li>[3] <a href="https://www.kernel.org/doc/html/latest/timers/highres.html">https://www.kernel.org/doc/html/latest/timers/highres.html</a></li>
<li>[4] <a href="https://www.youtube.com/watch?v=Puv4mW55bF8">https://www.youtube.com/watch?v=Puv4mW55bF8</a></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://blog.donkeysharp.xyz/es/mock-ec2-metadata/">
    <span class="title">¬´ Anterior</span>
    <br>
    <span>Simulando servidor de metadata de EC2 localmente</span>
  </a>
  <a class="next" href="https://blog.donkeysharp.xyz/es/post/gracias-profe-elias/">
    <span class="title">Siguiente ¬ª</span>
    <br>
    <span>Gracias Profe Elias</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Qu√© sucede cuando un proceso de Linux se va a dormir? on x"
            href="https://x.com/intent/tweet/?text=Qu%c3%a9%20sucede%20cuando%20un%20proceso%20de%20Linux%20se%20va%20a%20dormir%3f&amp;url=https%3a%2f%2fblog.donkeysharp.xyz%2fes%2fpost%2fwhat-happens-when-a-process-goes-to-sleep%2f&amp;hashtags=">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Qu√© sucede cuando un proceso de Linux se va a dormir? on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.donkeysharp.xyz%2fes%2fpost%2fwhat-happens-when-a-process-goes-to-sleep%2f&amp;title=Qu%c3%a9%20sucede%20cuando%20un%20proceso%20de%20Linux%20se%20va%20a%20dormir%3f&amp;summary=Qu%c3%a9%20sucede%20cuando%20un%20proceso%20de%20Linux%20se%20va%20a%20dormir%3f&amp;source=https%3a%2f%2fblog.donkeysharp.xyz%2fes%2fpost%2fwhat-happens-when-a-process-goes-to-sleep%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Qu√© sucede cuando un proceso de Linux se va a dormir? on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fblog.donkeysharp.xyz%2fes%2fpost%2fwhat-happens-when-a-process-goes-to-sleep%2f&title=Qu%c3%a9%20sucede%20cuando%20un%20proceso%20de%20Linux%20se%20va%20a%20dormir%3f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Qu√© sucede cuando un proceso de Linux se va a dormir? on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.donkeysharp.xyz%2fes%2fpost%2fwhat-happens-when-a-process-goes-to-sleep%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Qu√© sucede cuando un proceso de Linux se va a dormir? on whatsapp"
            href="https://api.whatsapp.com/send?text=Qu%c3%a9%20sucede%20cuando%20un%20proceso%20de%20Linux%20se%20va%20a%20dormir%3f%20-%20https%3a%2f%2fblog.donkeysharp.xyz%2fes%2fpost%2fwhat-happens-when-a-process-goes-to-sleep%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Qu√© sucede cuando un proceso de Linux se va a dormir? on telegram"
            href="https://telegram.me/share/url?text=Qu%c3%a9%20sucede%20cuando%20un%20proceso%20de%20Linux%20se%20va%20a%20dormir%3f&amp;url=https%3a%2f%2fblog.donkeysharp.xyz%2fes%2fpost%2fwhat-happens-when-a-process-goes-to-sleep%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Qu√© sucede cuando un proceso de Linux se va a dormir? on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Qu%c3%a9%20sucede%20cuando%20un%20proceso%20de%20Linux%20se%20va%20a%20dormir%3f&u=https%3a%2f%2fblog.donkeysharp.xyz%2fes%2fpost%2fwhat-happens-when-a-process-goes-to-sleep%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
<div class="comments">
  <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "blog-donkeysharp-xyz-1" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

</article>
    </main>
    
<footer class="footer">
        <span>¬© <a href="https://x.com/donkeysharp">Donkeysharp</a></span> ¬∑ 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copiar';

        function copyingDone() {
            copybutton.innerHTML = '¬°copiado!';
            setTimeout(() => {
                copybutton.innerHTML = 'copiar';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
